<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机系统结构</title>
      <link href="/2023/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
      <url>/2023/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统结构"><a href="#计算机系统结构" class="headerlink" title="计算机系统结构"></a>计算机系统结构</h1><h2 id="第一章-计算机系统结构的基本知识"><a href="#第一章-计算机系统结构的基本知识" class="headerlink" title="第一章 计算机系统结构的基本知识"></a>第一章 计算机系统结构的基本知识</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li><code>多层次结构</code>：按照计算机语言从低到高的次序，将计算机系统划分成多级层次结构，每一层以一种不同的语言为特征。这些特征依次为：<code>微程序机器级、传统机器语言机器级、操作系统机器级、汇编语言机器级、高级语言机器级、应用语言机器级</code>。</li><li><code>虚拟机</code>：指由<strong>软件实现</strong>的机器，以区别与由固件/硬件实现的物理机器</li><li><code>解释</code>：对于高一级机器上的程序的每一条语句或指令，都转去执行低一级机器上的一段等效代码。执行完后，再去高一级机器上取下一条语句或指令，再解释执行，如此反复执行，直到解释执行完整个程序。</li><li><code>翻译</code>：先用转换程序将高一级机器上的程序转换为低一级机器上的程序，然后在低一级机器上运行，完成程序的功能</li><li><code>计算机系统结构</code>：传统机器程序员所看到的计算机属性，即<strong>概念性结构</strong>和<strong>功能特性</strong></li><li><code>透明性</code>：指在计算机技术中，本来存在的事件或事物，但从某种角度看又好像不存在的概念</li><li><code>模拟</code>：用<strong>软件</strong>的方法在一台现有的计算机（称为宿主机Host）上实现另一台计算机（称为虚拟机）的指令集</li><li><code>仿真</code>：用一台现有的计算机的微程序去<strong>解释实现</strong>另一台计算机的指令系统</li><li><code>并行性</code>：指计算机系统在同一时刻或同一时间间隔内实现多种运算或操作。</li></ol><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol><li><p>多层次结构、物理机和虚拟机实现方法</p><blockquote><p>物理机由<strong>固件和硬件</strong>实现</p><p>虚拟机<strong>主要使用软件</strong>实现</p></blockquote></li><li><p>计算机组成和实现的概念及其关系</p><blockquote><p>计算机组成：<strong>计算机系统结构的逻辑实现</strong>，包括物理机的数据流和控制流的组成及其逻辑设计</p><p>计算机实现：<strong>计算机组成的物理实现</strong>，包括处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。它着眼于机器技术和维组装技术。</p><p>计算机系统结构、计算机组成、计算机实现之间的关系：计算机组成是计算机系统结构的逻辑实现。计算机实现是计算机组成的物理实现。一种系统结构有多种计算机组成。一种计算机组成有多种实现</p></blockquote><p><strong>系列机具有相同系统结构</strong></p></li><li><p>计算机系统结构的分类</p><p><code>Flynn分类法、冯氏分类法、Handler分类法</code></p><ul><li>Flynn分类法<ul><li>按照<code>指令流和数据流的多倍性</code>进行分类</li><li>CS 控制流</li><li>IS 指令流</li><li>CU 控制流</li><li>PU 处理部件</li><li>MM和SM 存储器</li><li>单指令单数据流(SISD)</li><li>单指令多数据流(SIMD)</li><li>多指令单数据流(MISD)</li><li>多指令多数据流(MIMD)</li></ul></li></ul><p><img src="/img/Flynn%E5%88%86%E7%B1%BB%E6%B3%95.png"></p><ul><li>冯氏分类法<ul><li>按照<code>系统最大并行度</code>分类</li><li>字宽(n)：一个字中同时处理的二进制位数</li><li>位片宽度(m)：在一个位片上能同时处理的字数</li><li>字串位串 n = 1, m = 1</li><li>字串位并 n &gt; 1, m = 1</li><li>字并位串 n = 1, m &gt; 1</li><li>字并位并 n &gt; 1, m &gt; 1</li></ul></li></ul></li><li><p>Amdahl定律的含义及计算方法、决定CPU性能的3个参数及计算方法、程序的局部性原理。</p><ol><li><p>含义及计算方法</p><blockquote><p>含义：当对一个系统的某个部件进行改进后，所能获得的整个系统性能的提高，受限于该部件执行时间占总执行事件的百分比</p><p>Fe：可改进比例</p><p>Se：部件加速比，改进前所需的执行时间与改进后执行时间的比</p><p>加速比：系统性能（改进后）/系统性能（改进前） = 总执行时间（改进前）/总执行时间（改进后）</p><p>改进后执行时间：Tn  = To ( 1 - Fe + Fe / Se)</p><p>总系统加速比：Sn = To / Tn = 1 / ( ( 1 - Fe) + Fe / Se)</p></blockquote></li><li><p>决定CPU性能的3个参数及计算方法</p><blockquote><p>1、时钟周期时间</p><p>2、CPI 指令的平均时钟周期数</p><p>3、IC 指令条数</p></blockquote></li><li><p>程序的局部性原理</p><blockquote><p>程序的局部性原理：程序执行时所访问的存储地址并不是随机分布，而是相对地簇聚</p><p>时间局部性：程序即将用到的信息可能就是目前正在使用的信息</p><p>空间局部性：程序即将用到的信息很可能与当前正在使用的信息在空间上相邻或邻近</p></blockquote></li></ol></li><li><p>计算机设计者的主要任务及计算机设计的主要方法</p><ul><li>主要任务<ul><li>确定用户对计算机系统的功能、价格和性能的要求</li><li>软硬件功能分配</li><li>设计出生命周期长的系统结构</li></ul></li><li>主要方法<ul><li>由上往下设计</li><li>由下往上设计</li><li>从中间开始设计</li></ul></li></ul></li><li><p>计算机性能的比较方法（p16）</p><ol><li>总执行时间</li><li>调和平均值法</li><li>几何平均值法</li></ol></li><li><p>冯•诺依曼结构的主要特点，指令系统的发展方向。</p><blockquote><p>主要特点</p><p>1、计算机以运算器为中心</p><p>2、在存储器中，指令和数据同等对待</p><p>3、存储器是按地址访问、按顺序线性编码的一维结构，每个单元的位数是固定的</p><p>4、指令的执行是顺序是，一般是按照指令在存储器中存放的顺序执行的</p><p>5、指令由操作码和地址吗组成</p><p>6、指令和数据均以二进制编码表示，采用二进制运算</p><p>发展方向</p><p>1、复杂指令集计算机</p><p>2、精简指令集计算机</p></blockquote></li><li><p>实现软件可移植性常用的三种方法</p><blockquote><p>统一高级语言、采用系列机、模拟和仿真</p></blockquote></li><li><p>并行性的概念，并行性的不同分类方法及各种分类方法各级的高低顺序，提高并行性的技术途径，耦合度的概念。</p><blockquote><p>并行性：计算机系统在同一时刻或同一时间间隔内进行多种运算或操作</p><p>从处理数据角度：字串位串、字串位并、字并位串、全并行</p><p>从执行程序角度：指令内部并行、指令级并行、线程级并行、任务级或过程级并行、作业或程序级并行</p><p>提高并行性的技术途径：时间重叠、资源重复、资源共享</p><p>耦合度的概念：多机系统中各计算机之前物理连接的紧密程度和交互作用能力的强弱</p></blockquote></li></ol><h2 id="第二章-指令系统的设计"><a href="#第二章-指令系统的设计" class="headerlink" title="第二章 指令系统的设计"></a>第二章 指令系统的设计</h2><p><strong>概念</strong></p><ol><li>寻址方式：指令系统中如何形成所要访问的数据的地址</li><li>指令系统的完整性：在一个有限可用的存储空间内，对于任何可解问题，编写程序时，指令系统所提供的指令足够使用</li><li>指令系统的规整性：包括对称性和均匀性<ol><li>对称性：所有与指令系统有关的存储单元的使用，操作码的设置必须是对称的</li><li>均匀性：对于各种不同的操作数类型、字长、操作种类和数据存储单元，指令的设置都要同等对待</li></ol></li><li>数据表示：计算机硬件能够直接识别，指令系统可以直接调用的数据类型</li><li>PC相对寻址：一种以程序计数器PC位参考点的寻址方式，主要用来转移指令中指定目标指令的地址</li><li>整数边界：信息在主存中存放的起始地址必须是该信息宽度（字节数）的整数倍</li></ol><p><strong>知识点</strong></p><ol><li><p>1、CPU用来存放操作数的存储单元和种类</p><p>​    堆栈、累加器、通用寄存器组</p><p>2、指令系统结构的分类</p><p>​    堆栈型结构、累加器型结构、通用寄存器型结构</p><p>3、理解堆栈型结构、累加器型结构和通用寄存器型结构三者的特点和不同</p><p>​    堆栈型：操作数都是隐式的，堆栈的栈顶和次栈顶的数据，运算后写入栈顶，只通过push、pop指令访问存储器</p><p>​    累加器型：累加器的操作数是隐式的，另一个操作数显示给出，是一个存储单元，运算结果送回累加器</p><p>​    通用寄存器组型：所有操作数都是显示给出，来自通用寄存器组或有一个操作数来自存储器，运算结果写入通用寄存器组</p><p> 4、通用寄存器型结构在灵活性和提高 性能方面的优势</p><p>​    寄存器的访问速度比存储器快很多，对编译器而言，能更加容易、有效地分配和使用寄存器，在表达方面，通用寄存器型结构具有更大的灵活性和更高的效率。寄存器可以用来存放变量。</p></li><li><p>指令系统设计的基本原则，指令的一般组成部分，哈夫曼编码、等长扩展码、定长编码方三种操作码编码方法（37）。</p><ol><li>基本原则：完整性、规整性、正交性、高效率、兼容性</li><li>组成部分：操作码和地址码</li></ol></li><li><p>CISC指令系统存在的问题，对CISC指令系统的改进方法；设计RISC计算机一般遵循的原则。</p><ol><li>存在的问题<ol><li>各种指令的使用频率相差悬殊，许多指令很少用到</li><li>指令系统庞大，指令条数很多，许多指令的功能很复杂</li><li>许多指令由于操作繁杂，CPI值较大，执行速度慢</li><li>由于指令功能复杂，规整性不好，不利于采用流水线技术提高性能</li></ol></li><li>改进方法<ol><li>面向目标程序增强指令系统</li><li>面向高级语言的优化实现来改进指令系统</li><li>面向操作系统的优化实现来改进指令系统</li></ol></li><li>原则<ol><li>指令条数，指令功能简单</li><li>采用简单而又统一的指令格式，并减少寻址方式，指令字长都为32位或64位</li><li>指令的执行在单周期内完成</li><li>采用Load-Store结构，只用使用Load和Store指令才能访问存储器</li><li>大多数指令都采用硬连逻辑来实现</li><li>强调优化编译器的作用，为高级语言程序生成优化后的代码</li><li>充分利用流水线技术来提高性能</li></ol></li></ol></li><li><p>表示操作数类型的方法</p><ol><li>由指令的操作码指定操作数的类型</li><li>给数据加上标识，由数据本身给出操作数的类型</li></ol></li><li><p>理解MIPS指令系统结构，熟练掌握3种指令格式，并熟悉其常用的指令（48）</p></li></ol><h2 id="第三章-流水线技术"><a href="#第三章-流水线技术" class="headerlink" title="第三章 流水线技术"></a>第三章 流水线技术</h2><p><strong>概念</strong></p><ol><li>流水线技术：把一个重复的过程分解成多个子过程，每个子过程由专门的功能部件来实现，把多个处理过程在时间是错开，依次通过各功能段。这样，每个子过程就可以和其他子过程并行进行。</li><li>通过时间：第一个任务从进入流水线到流出结果的那个时间段</li><li>排空时间：最后一个任务进入流水线到流出结果的那个时间段</li><li>定向技术：在某条指令产生一个计算结果之前，其他指令并不真正需要该计算结果，如果将该计算结果产生的地方直接送到其他指令需要他的地方，那么就可以避免暂停</li><li>单功能流水线：流水线之间的各段连接固定不变，只能完成一个固定功能的流水线</li><li>多功能流水线：流水线之间各段可以进行不同的连接，以完成不同功能的流水线</li><li>静态流水线：同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作</li><li>动态流水线：同一时间内，多功能流水线的各段可以按照不同的方式连接，同时执行多种功能的流水线</li><li>线性流水线：各段串行连接，没有反馈回路的流水线。数据通过流水线的同时，每一段最多只流过一次</li><li>非线性流水线：各段除了有串行的连接外，还有反馈回路的流水线</li></ol><p><strong>知识点</strong></p><ol><li><p>掌握流水线的基本概念（54）、流水线技术具有的特点（54）。</p></li><li><p>掌握流水线的工作原理、流水线的分类</p><p>工作原理：把一个重复的过程分解成多个子过程，每个子过程由专门的功能部件来实现，把多个处理过程在时间是错开，依次通过各功能段。这样，每个子过程就可以和其他子过程并行进行</p><p>流水线分类：</p><ol><li>部件级流水线、处理机级流水线及系统级流水线</li><li>单功能流水线与多功能流水线</li><li>静态流水线与动态流水线</li><li>线性流水线与非线性流水线</li><li>顺序流水线与乱序流水线</li></ol></li><li><p>理解流水线的各项性能指标及其计算方法（58）</p><p>1. </p></li><li><p>掌握消除流水线瓶颈的方法</p><ol><li><p>细分瓶颈段，把流水线的瓶颈切分为几个独立的功能段，从而使流水线各段的处理时间都相等</p></li><li><p>重复设置瓶颈段，重复设置的段并行工作，在时间上依次错开处理业务</p></li></ol></li><li><p>掌握单功能非线性流水线的最优调度方法，能熟练画出状态转换图、写出最优调度方案，熟悉多功能非线性流水线的调度</p></li><li><p>掌握经典5段流水线的结构</p><ol><li><p>取指令周期（IF）</p></li><li><p>指令译码/读寄存器周期（ID）</p></li><li><p>执行/有效地址计算周期（EX）</p></li><li><p>存储器访问/分支完成周期（MEM）</p></li><li><p>写回周期（WB）</p></li></ol></li><li><p>理解3种相关和3种冲突的概念，掌握解决结构冲突、数据冲突和控制冲突的方法。如何利用定向技术解决数据冲突？如何用猜测法和延迟分支解决控制冲突？</p><ol><li>三种相关：数据相关、名相关（反相关、输出相关）、控制相关</li><li>三种冲突：结构冲突、数据冲突、控制冲突</li></ol></li></ol><h2 id="第四章-向量处理机"><a href="#第四章-向量处理机" class="headerlink" title="第四章 向量处理机"></a>第四章 向量处理机</h2><p><strong>概念</strong></p><ol><li>横向处理方式：按行的方式从左到右进行计算</li><li>纵向处理方式：向量计算是按列的方式从上到下进行计算</li><li>向量流水线链接：具有先写后读相关的两条指令，在不出现功能部件冲突和其他vi冲突的情况下，可以把功能部件链接起来进行流水处理，以达到加快执行的目的</li><li>分段开采技术：当向量的长度大于向量寄存器的长度时，必须把长向量分成长度固定的段，然后循环分段处理，每一次循环只处理一个向量段</li></ol><p><strong>知识点</strong></p><ol><li><p>掌握有关向量处理的基本概念</p><p>向量是计算机系统中经常使用的一种数据类型，向量由一组有序、具有相同类型和位数的元素组成</p></li><li><p>掌握向量处理机的3种方式及其特点</p><ol><li>3种方式：横向处理方式、纵向处理方式、纵横处理方式</li><li>横向处理方式：若向量长度为N，则水平处理方式相当于执行N次循环。若使用流水线，在每次循环种可能出现数据相关和功能转换，不适合对向量进行流水处理</li><li>纵向处理方式：将整个向量按相同的运算处理完毕之后，再去执行其他运算。适合对向量进行流水处理，向量运算指令的源/目向量都放在存储器内，使得流水线运算部件的输入、输出端直接与存储器相连，构成M-M型的运算流水线</li><li>纵横处理方式：把长度为N的向量分为若干组，每组长度为n, 组内按纵向方式处理，一次处理各组，组数为[N / n]，适合流水处理。可设长度为n的向量寄存器，使每组向量运算的源/目向量都在向量寄存器中，流水线的运算部件输入、输出端与向量寄存器相连，构成R-R型运算流水线</li></ol></li><li><p>理解向量处理机的两种结构</p><ol><li>存储求-存储器结构</li><li>寄存器-寄存器结构</li></ol></li><li><p>掌握向量处理机上一个向量指令序列是否能并行执行或链接执行的判断方法，计算指令序列的总执行时间。</p><ol><li>102计算题</li></ol></li><li><p>掌握向量处理机的性能指标的定义及4计算方法。</p><ol><li>103计算题</li></ol></li><li><p>提高向量处理机性能的方法。</p><ol><li>设置多个功能部件</li><li>采用连接技术</li><li>采用循环开采技术</li><li>采用多处理系统</li></ol></li></ol><h2 id="第五章-指令级并行及其开发–硬件方法"><a href="#第五章-指令级并行及其开发–硬件方法" class="headerlink" title="第五章 指令级并行及其开发–硬件方法"></a>第五章 指令级并行及其开发–硬件方法</h2><p><strong>概念</strong></p><ol><li>指令级并行：指令之间存在并行性，利用它，计算机可以并行执行2条或2条以上的指令</li><li>循环级并行：开发循环的不同迭代之间存在的并行性</li><li>不精确异常：当执行指令i导致发生异常时，处理机的异常和严格按程序顺序执行的现场不同</li><li>精确异常：发生异常时，处理机的异常和严格按程序顺序执行的线程相同</li><li>超标量：一种多指令流出技术，它在每个时钟周期内流出的指令不固定，依代码的详细情况而定，但也有个上限</li><li>超流水：在一个时钟周期内分时流出多条指令</li><li>超长指令字：一种多指令流出技术，vliw处理机在每个时钟周期内流出的执行固定，这些指令构成一个长指令或指令包，在这个指令包中，指令的并行性通过指令显示的表示出来。</li></ol><p><strong>知识点</strong></p><ol><li><p>掌握有关指令并行的基本概念</p><p>指令级并行是指指令之间存在一种并行性，利用它，计算机考研并行执行2条或2条以上的指令</p></li><li><p>理解指令静态调度和动态调度的概念，指令动态调度有何优点，掌握Tomasulo算法的基本思想，Tomasulo算法中，指令流出段所做的主要工作。</p><ol><li>静态调度：静态调度的流水线依靠编译器对代码进行静态调度，以减少相关和冲突</li><li>动态调度：动态调度是在程序的执行过程中，依靠专门硬件对代码进行调度</li><li>指令动态调度优点：<ol><li>能够处理一些编译时情况不明的相关，并简化了编译器</li><li>能够使本来是面向某一流水线优化编译的代码在其他动态调度的流水线上也能高效运行。</li></ol></li><li>Tomasulo算法的基本思想<ol><li>记录和检测指令相关，操作数一旦就绪就立即执行，把发生RAW冲突的可能性减小到最小。</li><li>通过寄存器换名来消除WAR冲突和WAW冲突，寄存器换名是通过保留站来实现，它保存等待流出和正在流出指令所需要的操作数。</li></ol></li></ol></li><li><p>动态分支预测技术的目的是什么？在所采用的方法中，需要解决哪些关键技术？</p><ol><li>目的<ol><li>预测分支是否成功</li><li>尽快找到分支目标地址，从而避免控制相关造成流水线停顿</li></ol></li><li>关键技术<ol><li>如何记录分支的历史信息？要记录那些信息？</li><li>如何根据这些信息来预测分支的去向，甚至提前取出分支目标的指令</li></ol></li></ol></li><li><p>基于硬件的前瞻技术是把哪3种思想结合在一起？组成ROB中的每一项的4个字段；前瞻执行机制，指令执行的步骤。</p><ol><li>三种思想<ol><li>动态分支预测，用来选择后续执行的指令</li><li>在控制相关的结果尚未出来之前，前瞻地执行后续指令</li><li>用动态调度对基本块的各种组合进行跨基本块的调度</li></ol></li><li>四个字段：指令类型、目的地址、数据值字段、就绪字段</li><li>步骤：流出、执行、写结果、确认</li></ol></li><li><p>与VLIW处理机相比，超标量处理机的优点。</p><ol><li>超标量结果对程序员是透明的，处理机能直接检测下一条指令是否能够流出，不需要由编译器或专门的变换程序对程序的指令进行重新排列</li><li>即使是没有经过编译器针对超标量结构进行调度优化的代码或是旧的编译器生成的代码也可以运行，当然运行的效果不会很好，要达到很好的效果，就是使用动态超标量调度技术</li></ol></li><li><p>指令多流出处理器的流出能力受到的影响。</p><ol><li>程序所固有的指令机并行性（最简单最根本）</li><li>硬件上实现的困难</li><li>超标量和超长指令字处理器固有的技术限制</li></ol></li></ol><h2 id="第六章-指令级并行的开发–软件方法"><a href="#第六章-指令级并行的开发–软件方法" class="headerlink" title="第六章 指令级并行的开发–软件方法"></a>第六章 指令级并行的开发–软件方法</h2><p><strong>概念</strong></p><ol><li>指令调度：为了充分发挥流水线的作用，必须设法让它满负荷工作，这就要求充分开发指令之间存在的并行性，找出不相关的指令序列，让它们在流水线上重叠并行执行。</li><li>循环展开：循环体的代码复制多次并按顺序排放，然后相应地进行调整循环的结束条件</li><li>关键路径：根据指令间的相关关系构成的数据流图中延迟最长的一段路径</li><li>踪迹调度：踪迹调度的步骤：踪迹选择和踪迹压缩</li><li>前瞻执行：解决掌握相关的方法，它对分支指令的结构进行推测，然后按这个推测结果连续取值，流出和执行后续的指令；只是指令执行的结果不是写回到寄存器和储备器，而是放到一个ROB的缓冲器中；等到相应的指令得到确认后，才将结果写到寄存器或储备器</li></ol><p><strong>知识点</strong></p><ol><li>掌握相关的概念</li><li>掌握循环展开法和指令调度的基本方法。循环展开法和指令调度时注意的问题。<ol><li>循环展开和指令调度要注意几个方面<ol><li>保证正确性</li><li>注意有效性</li><li>使用不同的寄存器</li><li>删除多余的测试指令和分支指令</li><li>注意对存储器数据的相关性进行分析</li><li>注意新的相关性</li></ol></li></ol></li><li>全局指令调度的两种技术<ol><li>踪迹调度</li><li>超块调度</li></ol></li><li>显式并行计算（EPIC）结构必须符合的基本特点，EPIC高级优化技术。<ol><li>基本特点<ol><li>指令级并行主要由编译器负责开发，处理器应为保证代码正确执行提供必要的硬件支持，只有在这些硬件机制的辅助下这些优化技术才能高效完成。</li><li>系统结构必须提供某种通信机制，使得流水线硬件能够了解编译器“安排”好的指令执行顺序</li></ol></li><li>EPIC高级优化技术<ol><li>非绑定分支</li><li>谓词执行</li><li>前瞻执行</li></ol></li></ol></li><li>影响前瞻执行效果的因素；处理由前瞻指令引起异常的方法。<ol><li>因素<ol><li>编译器能力的高低</li><li>异常处理机制能否推迟处理</li><li>如何避免前缀引起的错误</li></ol></li><li>方法<ol><li>立即处理每一个异常</li><li>借助专门的检测指令判断是否需要进行异常处理</li><li>为每个通用增加一个标志位”poson”位，可继续异常将被立即处理，引发终止性异常时，目的寄存器R的poson位置1，否则改为清0。当之后的另一条指令访问R是，若poson位为1将触发一个终止性异常</li><li>将指令的执行结果保存到再定序缓冲器中，并将指令流出的顺序依次确认，但是前瞻指令的确认实际却被推迟，直至能够确定该指令都的前瞻指令是正确（错误）的</li></ol></li></ol></li><li>软流水技术的核心思想<ol><li>从循环中的不同迭代中抽取一部分指令拼成一个新的循环迭代，以便将同一迭代中的相关指令分布到痌的迭代中，或将不同迭代中的相关指令封装到同一迭代中。</li></ol></li></ol><h2 id="第七章-存储系统"><a href="#第七章-存储系统" class="headerlink" title="第七章 存储系统"></a>第七章 存储系统</h2><p><strong>概念</strong></p><ol><li>多级存储层次：采用不同的技术实现不同的存储器，处在离CPU不同距离的层次上，目标是达到离CPU最近的存储器的速度，最远的存储器的容量</li><li>命中时间：访问Cache命中时所花的时间</li><li>不命中开销：CPU向第二级存储器发出访问请求到把这个数据块调入低一级存储器所花的时间</li><li>替换算法：由于主存中的块比Cache中的块多，所以当要从主存中调一个块到Cache中时，会出现所映像的一组Cache块已被占用的情况，这时，需要被迫腾出一块，接纳被被调入的块</li><li>强制性不命中：当第一次访问一个块时，该块不在Cache中，需从下一级存储器中调入Cache</li><li>冲突不命中：在组相连或直接映射Cache中，若太多的块映射到同一组中，则会出现该组中的某一块被别的块替换、然后又被重新访问的情况</li></ol><p><strong>知识点</strong></p><ol><li><p>人们对存储系统的要求</p></li><li><p>程序访问的局部性原理</p><p>程序所访问的指令和数据在地址上不是均匀分布的，而是相对簇聚的，程序访问的局部性包括两个方面：时间局部性和空间局部性</p></li><li><p>存储系统的性能参数</p><ol><li>存储容量S</li><li>存储系统的平均每位价格C</li><li>命中率H</li><li>平均访存时间Ta</li></ol></li><li><p>三级存储系统的结构</p></li><li><p>存储层次要考虑的4个问题</p><ol><li>当把一个块（页）调入高一层（靠近CPU）存储器时，可以放到那些位置上？（映像规则）</li><li>当所要访问的块（页）在高一层存储器中时，如何找到该块（查找算法）</li><li>当发生不命中而且高一层存储器已经满时，应替换那一块（替换算法）</li><li>当进行写访问时，应进行那些操作（写策略）</li></ol></li><li><p>映像规则的类型</p><ol><li>全相联映像、直接映像、组相连映像</li></ol></li><li><p>替换算法的种类、优缺点</p><ol><li>随机法<ol><li>优点：简单、易于用硬件实现</li><li>缺点：命中率比较低</li></ol></li><li>先进先出法<ol><li>优点：容易实现</li><li>缺点：不能正确反映程序的局部性</li></ol></li><li>最近最少使用法<ol><li>优点：命中率高</li><li>缺点：硬件实现成本高</li></ol></li></ol></li><li><p>写策略的种类</p><ol><li>写直达法</li><li>写回法</li></ol></li><li><p>三种种类的不命中、降低不命中的方法</p><ol><li>三种种类<ol><li>强制性不命中</li><li>容量不命中</li><li>冲突不命中</li></ol></li><li>降低不命中的方法<ol><li>增加块的大小（最简单）</li><li>增加cache的容量（最直接）</li><li>提高相连度</li><li>伪相连cache</li><li>硬件预取</li><li>编译器控制的预取</li><li>编译优化</li><li>牺牲cache</li></ol></li></ol></li><li><p>并行存储器结构的类型，单体多字存储器访存效率不高的原因；多体交叉存储器的编址方法。</p><ol><li>类型<ol><li>单体多字存储器</li><li>多体交叉存储器</li></ol></li><li>原因<ol><li>单体多姿并行存储器一次能读取m个指令字</li><li>单体多字并行存储器一次取出的m个数据不一定都是有用的</li><li>在这个存储器中，必须凑齐了m个数之后才能一起写入存储器</li><li>当要读出的数据字和要写入的数据字处于同一场存储字内，读和写的操作无法在同一个存储周期内完成</li></ol></li><li>方法<ol><li>高位交叉编址</li><li>低位交叉编址</li></ol></li></ol></li></ol><h2 id="第八章-输入输出系统"><a href="#第八章-输入输出系统" class="headerlink" title="第八章 输入输出系统"></a>第八章 输入输出系统</h2><p><strong>概念</strong></p><ol><li>RAID：</li><li>响应时间：</li><li>可靠性：</li><li>可用性：</li><li>可信性：</li></ol><p><strong>知识点</strong></p><ol><li>评价I/O系统的主要性能参数</li><li>在磁盘阵列中设置冗余需要解决的问题</li><li>总线的主要特性</li><li>通道的功能、通道的主要硬件、通道的种类</li><li>通道的流量分析</li></ol><h2 id="第九章-互连网络"><a href="#第九章-互连网络" class="headerlink" title="第九章 互连网络"></a>第九章 互连网络</h2><p><strong>概念</strong></p><ol><li>互连网络：</li><li>互连函数：</li><li>自适应寻径：</li><li>静态互连网络：</li><li>动态互连网络：</li><li>结点度：</li></ol><p><strong>知识点</strong></p><ol><li>基本互连函数的表达式、规则</li><li>互连网络的性能指标</li><li>互连网络的分类</li><li>各种多级互连网络的区别、2×2开关模式连接的方式，开关模式控制的方式</li><li>三级立方体网络</li></ol><h2 id="第十章-多处理机"><a href="#第十章-多处理机" class="headerlink" title="第十章 多处理机"></a>第十章 多处理机</h2><p><strong>知识点</strong></p><ol><li>多Cache一致性：</li><li>旋转锁：</li><li>同时多线程：</li></ol><p><strong>概念</strong></p><ol><li>并行计算机系统结构分类</li><li>多处理的通信机制，两种通信机制的主要优点</li><li>存储器一致性满足的条件、实现一致性的基本方案、写作废协议和写更新协议在性能上的差别</li><li>目录的三种结构</li><li>并行计算机系统结构的分类</li></ol><h2 id="第十一章-多核架构与编程"><a href="#第十一章-多核架构与编程" class="headerlink" title="第十一章 多核架构与编程"></a>第十一章 多核架构与编程</h2><p><strong>概念</strong></p><ol><li>CMP：</li><li>SMT：</li><li>MPI：</li></ol><p><strong>知识点</strong></p><ol><li>并行编程模型的类型、各自的特点</li><li>多核技术的优点、多核架构的多处理器的不同</li><li>CPU发热取决的主要因素</li><li>多核时代的主要驱动力有哪些？</li></ol><h2 id="第十二-机群系统"><a href="#第十二-机群系统" class="headerlink" title="第十二 机群系统"></a>第十二 机群系统</h2><p><strong>概念</strong></p><ol><li>机群：</li><li>负载均衡机群：</li></ol><p><strong>知识点</strong></p><ol><li>机群的特点</li><li>机群的分类</li></ol><h2 id="第十三章-多处理机"><a href="#第十三章-多处理机" class="headerlink" title="第十三章 多处理机"></a>第十三章 多处理机</h2><p><strong>概念</strong></p><ol><li>阵列处理机</li><li>阵列控制器</li></ol><p><strong>知识点</strong></p><ol><li>阵列处理操作模型的组成，阵列处理机的特点</li><li>阵列处理机基本结构分类</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2023/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2023/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h2><h4 id="1-1-计算机发展历程"><a href="#1-1-计算机发展历程" class="headerlink" title="1.1 计算机发展历程"></a>1.1 计算机发展历程</h4><p><strong>1、计算机硬件的发展</strong></p><p><strong>计算机四代变化</strong></p><table><thead><tr><th align="center">计算机发展</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">第一代计算机——<strong>电子管</strong>时代（1946~1957）</td><td align="center">逻辑元件采用电子管、机器语言编程、延迟线或磁鼓信息存储</td></tr><tr><td align="center">第二代计算机——<strong>晶体管</strong>时代（1958~1964）</td><td align="center">逻辑元件采用晶体管、磁芯存储、开始出现<strong>高级语言</strong>、<strong>操作系统</strong></td></tr><tr><td align="center">第三代计算机——<strong>中小规模集成电路</strong>时代（1965~1971）</td><td align="center">逻辑元件采用中小规模集成电路、半导体存储器、出现<strong>分时操作系统</strong></td></tr><tr><td align="center">第四代计算机——<strong>超大规模集成电路</strong>时代（1972~至今）</td><td align="center">逻辑元件采用<strong>大规模集成电路</strong>和<strong>超大规模集成电路</strong>、<strong>微处理器（并行、流水线、高速缓存、虚拟存储器）</strong></td></tr></tbody></table><p><strong>计算机元件的更新换代</strong></p><ul><li>摩尔定律：每隔18个月，集成电路上的晶体管数目增加一倍，性能提升一倍</li><li>半导体存储器的发展：半导体存储器经历了11代</li><li>微处理器的发展</li></ul><p><strong>2、计算机软件的发展</strong></p><h4 id="1-2-计算机系统层次结构"><a href="#1-2-计算机系统层次结构" class="headerlink" title="1.2 计算机系统层次结构"></a>1.2 计算机系统层次结构</h4><p><strong>1、计算机系统的组成</strong></p><p>硬件系统和软件系统共同构成了一个完整的计算机系统。</p><ul><li>硬件：有形的物理设备， 是计算机系统中实际物理装置的总称</li><li>软件：硬件上运行的程序和相关的数据及文档</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">硬件系统：</span><br><span class="line">- 运算器</span><br><span class="line">- 存储器</span><br><span class="line">- 控制器</span><br><span class="line">- 输入/输出设备</span><br></pre></td></tr></table></figure><p><strong>2、计算机硬件</strong></p><p><strong>①、冯诺依曼机基本思想</strong></p><p><strong>特点</strong></p><ol><li>采用<code>存储程序</code>的工作方式</li><li>计算机硬件系统有<code>运算器、存储器、控制器、输入设备和输出设备</code>5大部分组成</li><li><code>指令和数据以同等地位</code>存储在存储器中</li><li>指令和数据都是以二进制代码表示</li><li>指令由<code>操作码</code>和<code>地址码</code>组成</li></ol><p><strong>存储程序</strong>的基本思想：将事先编制好的程序和原始数据存入主存，计算机自动执行</p><p><strong>②、计算机的功能部件</strong></p><p><code>输出/输出设备（I/O）是计算机与外界联系的桥梁</code></p><p><code>MAR和MDR虽然是存储器一部分，但是现代计算机中多存在于CPU（运算器、控制器）中</code></p><p><code>运算器和控制器集成在一个芯片上，成为中心处理器（CPU），CPU与主存储器共同构成主机</code></p><ul><li><p><strong>输入设备</strong></p><ul><li>功能：将程序和数据以机器所能识别和接受的信息形式输入计算机。如键盘、鼠标、扫描仪、摄像机等</li></ul></li><li><p><strong>输出设备</strong></p><ul><li>功能：将计算机处理的结果以人们能够接受的形式或其他系统所要求的信息形式输出。如显示器、打印机。</li></ul></li><li><p><strong>存储器</strong></p><ul><li>主存储器（内存储器）：<strong>CPU能够直接访问</strong>的存储器</li><li>辅助存储器（外存储器）：用于帮助主存储器记忆更多信息，辅助存储器的信息必须调入主存，才能被CPU访问</li><li>主存工作方式：<code>按地址存取方式</code>（按存储单元的地址进行存取）</li><li>主存基本组成：<ul><li>存储体：存放二进制信息，由存储单元（<strong>存储字、存储字长</strong>）组成</li><li>地址寄存器（MAR）：存放访存地址，经过地址译码后找到所选的存储单元。<strong>其位数对应存储单元个数</strong> 10位—&gt;2^10个存储单元，<strong>MAR长度等于PC长度</strong></li><li>数据寄存器（MDR）：用于暂存要从存储器中读或写的信息。<strong>MDR位数等于存储字长</strong></li></ul></li></ul></li><li><p><strong>运算器</strong>：计算机的<strong>执行部件</strong>，进行算术运算和逻辑运算</p><ul><li>核心：算术逻辑单元（ALU）</li><li>寄存器：<ul><li>累加器（ACC）</li><li>乘商寄存器（MQ）</li><li>操作数寄存器（X）</li></ul></li></ul></li><li><p><strong>控制器</strong>：计算机的<strong>指挥中心</strong>，指挥各部件自动协调运行</p><ul><li>组成：PC、IR、CU<ul><li>程序计数器（PC）：存放当前欲执行指令的地址，自动+1</li><li>指令寄存器（IR）：存放当前指令</li><li>控制单元（CU）</li></ul></li></ul></li></ul><p><strong>3、计算机软件</strong></p><p><strong>按功能分类</strong>：系统软件、应用软件</p><blockquote><p><strong>系统软件</strong>：一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源</p><p><strong>应用软件</strong>：用户为解决某个领域中的各类问题而编制的程序</p></blockquote><p><strong>三个级别的语言</strong></p><blockquote><p><strong>机器语言</strong>：二进制语言，计算机能直接识别和执行的语言</p><p><strong>汇编语言</strong>：使用英文单词或其缩写代替二进制的指令代码，需要汇编程序翻译成机器语言执行</p><p><strong>高级语言</strong>：高级语言（c、c++、java等）是方便程序设计人员写出解决问题的处理方案和解题过程的程序。需要高级语言程序翻译为汇编语言程序，然后经过汇编操作得到机器语言程序</p></blockquote><p><strong>4、计算机系统的层次结构</strong></p><table><thead><tr><th align="center">层级</th><th align="center">结构</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">第五层（软件）</td><td align="center">虚拟机器M4（高级语言机器）</td><td align="center">用编译程序翻译成汇编语言程序</td></tr><tr><td align="center">第四层（软件）</td><td align="center">虚拟机器M3（汇编语言机器）</td><td align="center">用汇编语言程序翻译成机器语言程序</td></tr><tr><td align="center">第三层（软件）</td><td align="center">虚拟机器M2（操作系统机器）</td><td align="center">用机器语言解释操作系统</td></tr><tr><td align="center">第二层（硬件）</td><td align="center">传统机器M1（使用机器语言的机器）</td><td align="center">用微程序解释机器指令</td></tr><tr><td align="center">第一层（硬件）</td><td align="center">微程序机器M0（微指令系统）</td><td align="center">用硬件直接执行微指令</td></tr></tbody></table><h4 id="1-3-计算机的性能指标"><a href="#1-3-计算机的性能指标" class="headerlink" title="1.3 计算机的性能指标"></a>1.3 计算机的性能指标</h4><p><strong>1、计算机的主要性能指标</strong></p><p><strong>字长</strong>：计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数，通常与CPU的寄存器位数、加法器有关。字长一般等于内部寄存器的大小，字长越长，数的表示返回越大，计算精度越高。计算机字长通常为字节（8位）的整数倍。</p><p><strong>数据通路带宽</strong>：数据总线一次所能并行传送信息的位数，指外部数据总线的宽度，与CPU内部的数据总线宽度可能不同。</p><blockquote><p> 注意：各个子系统通过数据总线连接形成的数据传送路径成为<strong>数据通路</strong></p></blockquote><p><strong>主存容量</strong>：主存储器所能存储信息的最大容量，通常以字节衡量。MAR位数反应存储单元个数，MAR位数反映可寻址范围的最大值</p><p><strong>运算速度</strong></p><blockquote><p>1、吞吐量：指系统在单位时间内处理请求的数量</p><p>2、响应时间：指从用户向计算机发送一起请求，到系统对该请求做出响应并获取所需结果的等待时间，包括CPU时间与等待时间</p><p>3、主频（CPU时钟频率）：机器内部主时钟的频率，是衡量机器速度的重要参数。常用主频有：1.8GHz，2.4GHZ</p><p>4、CPU时钟周期：主频的倒数</p><p>​    <code>CPU时钟周期= 1 / 主频</code></p><p>5、CPI（Clock cycle Per Instrucion）：执行一条指令所需的时钟周期数</p><p>6、CPU执行时间：运行一个程序所花费的时间</p><p>​    <code>CPU执行时间 = CPU时钟周期数 / 主频 = （指令条数 × CPI）/ 主频</code></p><p>7、MIPS：每秒执行多少百万条指令</p><p>​    <code>MIPS = 指令条数 / （执行时间 × 10 ^ 6 ）= 主频 / （CPI × 10 ^ 6) </code></p></blockquote><p><strong>基准程序</strong>：专门用来进行性能评价的一组程序</p><p><strong>2、几个专业术语</strong></p><p>1、<strong>系列机</strong>：具有基本相同的体系结构</p><p>2、<strong>兼容</strong>：指软件或硬件的通用性</p><p>3、<strong>软件可移植性</strong>：指把使用在某个系列计算机中软件直接或进行很少的修改就能运行在另一个系列计算机的可能性</p><p>4、<strong>固件</strong>：将程序固化在ROM中组成的部件称为固件</p><h2 id="第二章-数据的表示和运算"><a href="#第二章-数据的表示和运算" class="headerlink" title="第二章 数据的表示和运算"></a>第二章 数据的表示和运算</h2><h2 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h2><h2 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h2><h2 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h2><h2 id="第六章-总线"><a href="#第六章-总线" class="headerlink" title="第六章 总线"></a>第六章 总线</h2><h2 id="第七章-输入-输出系统"><a href="#第七章-输入-输出系统" class="headerlink" title="第七章 输入/输出系统"></a>第七章 输入/输出系统</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 - 组成原理 - 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="第一章：计算机网络体系结构"><a href="#第一章：计算机网络体系结构" class="headerlink" title="第一章：计算机网络体系结构"></a>第一章：计算机网络体系结构</h2><h4 id="1、计算机网络概述"><a href="#1、计算机网络概述" class="headerlink" title="1、计算机网络概述"></a>1、计算机网络概述</h4><p><strong>①概念</strong>：计算机网络是一个将<code>分散的、具有独立功能</code>的计算机系统，通过<code>通信设备与线路</code>连接起来，由功能完善的软件实现<code>资源共享</code>和<code>信息传递</code>的系统。</p><p><strong>②计算机网络的组成</strong>：</p><p>从<code>组成部分</code>来看，完整的计算机网络主要由<code>硬件、软件、协议</code>三部分组成。</p><table><thead><tr><th align="center">组成</th><th align="center">定义</th></tr></thead><tbody><tr><td align="center">硬件</td><td align="center">主要由主机（端系统）、通信链路（双绞线、光纤）、交换设备（路由器、交换机）、通信处理机（网卡）组成</td></tr><tr><td align="center">软件</td><td align="center">主要包括各种实现资源共享的软件和方便用户使用的各种工具软件（如网络操作系统、邮件收发系统、FTP系统、聊天程序等），主要部分属于应用层</td></tr><tr><td align="center">协议</td><td align="center">协议是计算机网络的核心，协议规定网络传输数据时所遵循的规范</td></tr></tbody></table><p>从<code>工作方式</code>上看，计算机网络（主要指Internet，即因特网）可分为<code>边缘部分</code>和<code>核心部分</code></p><table><thead><tr><th align="center">组成</th><th align="center">定义</th></tr></thead><tbody><tr><td align="center">边缘部分</td><td align="center">由所有连接到因特网、供用户使用的主机组成，用于通信和资源共享</td></tr><tr><td align="center">核心部分</td><td align="center">由大量的网络和连接这些网络的路由器组成，为边缘服务提供连通性和交换服务</td></tr></tbody></table><p>从<code>功能组成</code>上看，计算机网络由<code>通信子网</code>和<code>资源子网</code>组成</p><table><thead><tr><th align="center">组成</th><th align="center">定义</th></tr></thead><tbody><tr><td align="center">通信子网</td><td align="center">由各种传输介质、通信设备和网络协议组成，实现联网计算机之间的数据通信</td></tr><tr><td align="center">资源子网</td><td align="center">实现资源共享功能的设备及其软件的集合，向网络用户提供硬件资源、软件资源和数据资源的服务</td></tr></tbody></table><p><strong>③计算机网络的功能</strong></p><ul><li>数据通信</li><li>资源共享</li><li>分布式处理</li><li>提供可靠性</li><li>负载均衡</li></ul><p><strong>④计算机网络的分类</strong></p><p><strong>按分布范围分类</strong></p><ul><li>广域网（WAN）：直径几十千米到几千千米，使用<code>交换技术</code>，也称<code>远程网，是因特网的核心</code></li><li>城域网（MAN）：直径5~50km，多采用<code>以太网</code>技术</li><li>局域网（LAN）：直径几十到几千米，使用<code>广播技术</code></li><li>个人局域网（PAN）：直径约10米，也称<code>无线个人局域网（WPAN）</code></li></ul><p><strong>按传输技术分类</strong></p><ul><li>广播式网络</li><li>点对点网络</li></ul><p><strong>按拓扑结构分类</strong></p><ul><li>总线形网络：用单根传输线把计算机连接起来 <ul><li>优点：建网容易、增/减结点方便、节省线路</li><li>缺点：重负载时通信效率不高，总线任意一处对故障敏感</li></ul></li><li>星形网络：每个终端或计算机都以单独的线路与中央设备相连<ul><li>优点：便于集中控制和管理</li><li>成本高、中央设备对故障敏感</li></ul></li><li>环形网络：所有计算机接口设备连接成一个环</li><li>网状网络<ul><li>优点：可靠性高</li><li>缺点：控制复杂、线路成本高</li></ul></li></ul><p><strong>按使用者分类</strong></p><ul><li>公用网</li><li>专用网</li></ul><p><strong>按交换技术分类</strong></p><p>交换技术是指<code>各台主机之间、各通信设备之间</code>或主机与通信设备之间<code>为交换信息所采用的数据格式和交换装置</code>的方式</p><ul><li>电路交换网络<ul><li>定义：在源结点和目的结点之间建立一条专用的通道用于传送数据，包括<code>建立连接、传输数据和断开连接</code>三个阶段</li><li>优点：数据直接传送、时延小</li><li>缺点：线路利用率低，不能充分利用线路容量、不便于进行差错控制</li></ul></li><li>报文交换网络<ul><li>定义：用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文，也称<code>存储-转发网络</code></li><li>优点：充分利用线路容量，实现差错控制</li><li>缺点：增大资源开销、增加缓存时延、缓冲区难以管理</li></ul></li><li>分组交换网络<ul><li>也称<code>包交换网络</code>，将数据分成较短的固定长度的数据块，每个数据块加上目的地址、源地址等信息组成分组（包），以<code>存储-转发</code>方式传输</li><li>优点：充分利用线路容量，实现差错控制、缓存易于管理、包的平均时延更小、易于标准化。目前主流网络基本可视为分组交换网络</li></ul></li></ul><p><strong>按传输介质分类</strong></p><ul><li>无线：蓝牙、微波、无线电等</li><li>有线：双绞线网络、同轴电缆网络</li></ul><p><strong>⑤*计算机网络的标准化工作</strong></p><p>因特网的所有标准都以RFC(Request For Comments)的形式在因特网发布</p><p>负责指定、实施相关网络标准的标准化组织主要如下：</p><ul><li>国际标准化组织（ISO）</li><li>国际电信联盟（ITU）</li><li>国际电气电子工程师协会（IEEE）</li></ul><p><strong>⑥计算机网络的性能指标</strong></p><p>1）<strong>宽带（Bandwidth）</strong>：表示网络的通信线路所能传送数据的能力，单位比特/秒（b/s）</p><p>2）<strong>时延（Delay）</strong>：指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间，它有四部分组成：发送时延、传播时延、处理时延和排队时延</p><ul><li>发送时延 = 分组长度/信道宽度</li><li>传播时延 = 信道长度/电磁波在信道上的传播速率</li><li>处理时延 </li><li>排队时延</li></ul><p><strong>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</strong></p><p>3）<strong>时延带宽积</strong>：指发送端发送的第一个比特即将到达终点是，发送端已经发出多少比特 <code>时延带宽积 = 传播时延 × 信道带宽</code></p><p>4）**往返时延（Round-Trip time, RTT)**：从发送端发出一个端分组，到发送端收到来自接收端的确定，总共经历的时延</p><p>5）<strong>吞吐量（Throughput）</strong>：指单位时间内通过某个网络（或信道、接口）的数据量</p><p>6）<strong>速率（Speed）</strong>：网络的速率指连接到计算机网络上的主机在数字信道上传送数据的速率，也称数据传输速率、数据率或比特率，单位 b/s、bit/s、bps、kb/s、Mb/s、Gb/s，计算机网络中，最高数据传输速率称为带宽</p><p>7）<strong>信道利用率</strong>：信道利用率 = 有数据通过时间/(有 + 无)数据通过时间</p><h4 id="2、计算机网络体系结构与参考模型"><a href="#2、计算机网络体系结构与参考模型" class="headerlink" title="2、计算机网络体系结构与参考模型"></a>2、计算机网络体系结构与参考模型</h4><h2 id="第二章：物理层"><a href="#第二章：物理层" class="headerlink" title="第二章：物理层"></a>第二章：物理层</h2><h4 id="1、通信基础"><a href="#1、通信基础" class="headerlink" title="1、通信基础"></a>1、通信基础</h4><h4 id="2、传输介质"><a href="#2、传输介质" class="headerlink" title="2、传输介质"></a>2、传输介质</h4><h4 id="3、物理层设备"><a href="#3、物理层设备" class="headerlink" title="3、物理层设备"></a>3、物理层设备</h4><h2 id="第三章：数据链路层"><a href="#第三章：数据链路层" class="headerlink" title="第三章：数据链路层"></a>第三章：数据链路层</h2><h4 id="1、数据链路层的功能"><a href="#1、数据链路层的功能" class="headerlink" title="1、数据链路层的功能"></a>1、数据链路层的功能</h4><h4 id="2、组帧"><a href="#2、组帧" class="headerlink" title="2、组帧"></a>2、组帧</h4><h4 id="3、差错控制"><a href="#3、差错控制" class="headerlink" title="3、差错控制"></a>3、差错控制</h4><h4 id="4、流量控制与可靠传输机制"><a href="#4、流量控制与可靠传输机制" class="headerlink" title="4、流量控制与可靠传输机制"></a>4、流量控制与可靠传输机制</h4><h4 id="5、介质访问控制"><a href="#5、介质访问控制" class="headerlink" title="5、介质访问控制"></a>5、介质访问控制</h4><h4 id="6、局域网"><a href="#6、局域网" class="headerlink" title="6、局域网"></a>6、局域网</h4><h4 id="7、广域网"><a href="#7、广域网" class="headerlink" title="7、广域网"></a>7、广域网</h4><h4 id="8、数据链路层设备"><a href="#8、数据链路层设备" class="headerlink" title="8、数据链路层设备"></a>8、数据链路层设备</h4><h2 id="第四章：网络层"><a href="#第四章：网络层" class="headerlink" title="第四章：网络层"></a>第四章：网络层</h2><h4 id="1、网络层的功能"><a href="#1、网络层的功能" class="headerlink" title="1、网络层的功能"></a>1、网络层的功能</h4><h4 id="2、路由算法"><a href="#2、路由算法" class="headerlink" title="2、路由算法"></a>2、路由算法</h4><h4 id="3、IPv4"><a href="#3、IPv4" class="headerlink" title="3、IPv4"></a>3、IPv4</h4><h4 id="4、IPv6"><a href="#4、IPv6" class="headerlink" title="4、IPv6"></a>4、IPv6</h4><h4 id="5、路由协议"><a href="#5、路由协议" class="headerlink" title="5、路由协议"></a>5、路由协议</h4><h4 id="6、IP组播"><a href="#6、IP组播" class="headerlink" title="6、IP组播"></a>6、IP组播</h4><h4 id="7、移动IP"><a href="#7、移动IP" class="headerlink" title="7、移动IP"></a>7、移动IP</h4><h4 id="8、网络层设备"><a href="#8、网络层设备" class="headerlink" title="8、网络层设备"></a>8、网络层设备</h4><h2 id="第五章：传输层"><a href="#第五章：传输层" class="headerlink" title="第五章：传输层"></a>第五章：传输层</h2><h4 id="1、传输层提供的服务"><a href="#1、传输层提供的服务" class="headerlink" title="1、传输层提供的服务"></a>1、传输层提供的服务</h4><h4 id="2、UDP协议"><a href="#2、UDP协议" class="headerlink" title="2、UDP协议"></a>2、UDP协议</h4><h4 id="3、TCP协议"><a href="#3、TCP协议" class="headerlink" title="3、TCP协议"></a>3、TCP协议</h4><h2 id="第六章：应用层"><a href="#第六章：应用层" class="headerlink" title="第六章：应用层"></a>第六章：应用层</h2><h4 id="1、网络应用模型"><a href="#1、网络应用模型" class="headerlink" title="1、网络应用模型"></a>1、网络应用模型</h4><h4 id="2、域名系统（DNS）"><a href="#2、域名系统（DNS）" class="headerlink" title="2、域名系统（DNS）"></a>2、域名系统（DNS）</h4><h4 id="3、文件传输协议（FTP）"><a href="#3、文件传输协议（FTP）" class="headerlink" title="3、文件传输协议（FTP）"></a>3、文件传输协议（FTP）</h4><h4 id="4、电子邮件"><a href="#4、电子邮件" class="headerlink" title="4、电子邮件"></a>4、电子邮件</h4><h4 id="5、万维网（WWW）"><a href="#5、万维网（WWW）" class="headerlink" title="5、万维网（WWW）"></a>5、万维网（WWW）</h4>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 - 网络 - 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go常见面试题-入门</title>
      <link href="/2023/03/11/Go%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/Go%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/03/11/Go%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/Go%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Go相较其他语言的优势"><a href="#1-Go相较其他语言的优势" class="headerlink" title="1.Go相较其他语言的优势"></a>1.Go相较其他语言的优势</h4><ul><li>Golang在语言层次支持高并发</li><li>Golang的代码默认执行GoFmt格式化，保证代码风格统一</li><li>Golang的垃圾回收与程序可以同时进行，效率比Java、python更有效</li></ul><h4 id="2-Go的数据类型"><a href="#2-Go的数据类型" class="headerlink" title="2.Go的数据类型"></a>2.Go的数据类型</h4><ul><li><p>布尔类型（bool）</p></li><li><p>数值类型，包括整数（int,int8,int16,int32,int64)、无符号整数（uint,uint8,uint16,uint32,uint64,uintptr)、浮点数（float32, float64)</p></li><li><p>复数类型（complex64、complex128)</p></li><li><p>字符串类型（string）</p></li><li><p>数组类型（array）</p></li><li><p>切片类型（slice）</p></li><li><p>字典类型（map）</p></li><li><p>通道（channel）</p></li><li><p>指针（pointer）</p></li><li><p>结构体类型（struct）</p></li><li><p>接口类型（interface）</p></li><li><p>函数类型（func）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go后端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="一、计算机系统概述"><a href="#一、计算机系统概述" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h2><h4 id="1、操作系统的基本概念"><a href="#1、操作系统的基本概念" class="headerlink" title="1、操作系统的基本概念"></a>1、操作系统的基本概念</h4><p>概念 ：<code>操作系统（Operating System, OS)</code>是指控制和管理整个计算机系统的硬件和软件资源，合理的组织、调度计算机的工作和资源的分配，进而为用户和其他软件提供方便接口系统环境的程序集合。操作系统是计算机系统中<code>最基本的系统软件</code></p><p>特征</p><ul><li><code>并发（Concurrence）</code>：宏观上多道程序同时执行，微观上程序是分时交替执行的</li><li><code>共享（Sharing）</code>：资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用，有两种方式<ul><li>互斥共享方式</li><li>同时访问方式（宏观上）</li></ul></li><li><code>虚拟（Virtual）</code>：指把一个物理上的实体变为若干逻辑上的对应物 -&gt;虚拟技术、虚拟处理器、虚拟存储器<ul><li>时分复用技术 - &gt;处理器的分时共享</li><li>空分复用技术 - &gt;虚拟存储器</li></ul></li><li><code>异步（Asynchronism）</code>：多道环境允许多个程序并发执行，但进程的执行以不可预知的速度向前推进，使得操作系统运行在一种随机的环境下</li></ul><p>目标和功能</p><ul><li>操作系统作为计算机系统资源的管理者（上层）<ul><li><code>处理机管理</code>：进程管理、进程同步、进程通信、死锁处理、处理机调度等</li><li><code>存储器管理</code>：内存分配、地址映射、内存保护和共享和内存扩充等</li><li><code>文件管理</code>：文件存储空间管理、目录管理、文件读写管理等</li><li><code>设备管理</code>：缓存管理、设置分配、设备处理和虚拟设备等</li></ul></li><li>操作系统作为用户与计算机硬件系统之间的接口（中间层）<ul><li><code>命令接口</code>：用户利用这些命令命令来组织和控制作业的执行<ul><li>联机命令接口（交互式命令接口）：单命令执行，交互性强</li><li>脱机命令接口（批处理命令接口）：根据一组作业控制命令执行，无法干预</li></ul></li><li><code>程序接口</code>：编程人员可以使用它们来请求操作系统服务<ul><li>由一组系统调用（广义指令）组成，间接使用系统调用</li></ul></li></ul></li><li>操作系统实现了对计算机资源的扩充<ul><li><code>裸机</code>：没有任何软件支持的计算机成为</li><li><code>扩充机器（虚拟机）</code>：覆盖了软件的计算机</li></ul></li></ul><h4 id="2、操作系统发展历程"><a href="#2、操作系统发展历程" class="headerlink" title="2、操作系统发展历程"></a>2、操作系统发展历程</h4><ul><li><p><code>手工操作阶段（无操作系统）</code>：所有工作人工干预</p><ul><li>缺点：①用户独占全机，资源利用率低。②CPU等待手工操作，CPU利用不充分</li></ul></li><li><p><code>批处理阶段（操作系统开始出现）</code>：为了解决人机矛盾及CPU和I/O设备之间的速度不匹配</p><ul><li>单道批处理系统：系统对作业的处理是成批进行的，但内存始终保存一道作业<ul><li>自动性：作业逐个运行，无须人工干预</li><li>顺序性：</li><li>单道性：内存中仅有一道程序</li></ul></li><li>多道批处理系统：运行多个程序同时进入内存和请求CPU，特点是多道、宏观上并行、微观上串行<ul><li>优点：资源利用率高、系统吞吐量达，CPU保持“忙碌”状态</li><li>缺点：用户响应时间长、不提供交互能力</li></ul></li></ul></li><li><p><code>分时操作系统</code>：指把处理器的运行时间分成很短的时间片，轮流交给处理器分配联机作业使用</p><ul><li>同时性</li><li>交互性</li><li>独立性</li><li>及时性</li></ul></li><li><p><code>实时操作系统</code>：为了在某个时间限制内完成某些紧急任务而不需要时间片排队</p><ul><li>硬实时系统：某个动作必须绝对地在规定的时刻完成</li><li>软实时系统：在硬实时系统基础上，能接受偶尔违反规定</li></ul></li><li><p><code>网络操作系统和分布式计算机系统</code></p></li><li><p><code>个人计算机操作系统</code></p></li></ul><h4 id="3、操作系统运行j机制和体系结构"><a href="#3、操作系统运行j机制和体系结构" class="headerlink" title="3、操作系统运行j机制和体系结构"></a>3、操作系统运行j机制和体系结构</h4><ul><li>运行机制<ul><li>两种指令<ul><li><code>特权指令</code>：不允许用户直接使用的指令</li><li><code>非特权指令</code>：允许用户直接使用的指令</li></ul></li><li>两种处理器状态<ul><li>核心态</li><li>用户态</li></ul></li><li>两种程序<ul><li>内核程序</li><li>应用程序</li></ul></li></ul></li><li>操作系统内核<ul><li>时钟管理</li><li>中断管理<ul><li>中断机制的诞生：为了实现多道程序并发执行而引入的一种技术</li><li>中断的概念和作用<ul><li>发送中断，就意味着需要操作系统接入开展管理工作，CPU会立即进入核心态</li><li>“中断“是CPU从用户态进入核心态的唯一途径</li></ul></li><li>中断的分类<ul><li>内中断（也称异常、例外、陷入）<ul><li>自愿中断——指令中断</li><li>强迫中断——硬件故障、软件中断</li></ul></li><li>外中断<ul><li>外设请求</li><li>人工干预</li></ul></li></ul></li><li>补充：内中断的另一种分类方式<ul><li>陷阱、陷入（trap）</li><li>故障（fault）</li><li>终止（abort）</li></ul></li><li>外中断的处理过程<ul><li>每条指令执行结束后，CPU检查是否有外部中断信号</li><li>若有外部中断信号，则需要保护被中断进程的CPU环境</li><li>根据中断信号类型转入相应的中断处理程序</li><li>恢复原进程CPU环境并推出中断，返回原进程继续往下执行</li></ul></li></ul></li><li>原语：一种特殊的程序，其执行具有原子性</li><li>对系统资源进行管理的功能<ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul></li><li>操作系统的体系结构<ul><li>大内核<ul><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li></ul></li><li>微内核<ul><li>优点：内核功能少，结构清晰，方便维护</li><li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li></ul></li></ul></li></ul><h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><h4 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h4><ul><li>定义：进程是进程实体（进程映像）的运行过程，是系统进行资源分配和调度的一个独立单位</li><li>组成<ul><li>PCB（Process Control Block）<ul><li>进程描述信息</li><li>进行控制和管理信息</li><li>资源分配清单</li><li>处理机相关信息</li></ul></li><li>程序段：存放要执行的程序代码</li><li>数据段：存放程序运行过程中处理的各种数据</li></ul></li><li>组织方式<ul><li>链接方式：按进程状态将PCB分为多个队列</li><li>索引方式：按照进程状态建立多张索引表，各表项指向一个PCB</li></ul></li><li>特征<ul><li>动态性：进程的最基本特征</li><li>并发性</li><li>独立性：进程是系统进行资源分配、调度的独立单位</li><li>异步性：各进程以不可预知的速度向前推进，可能导致运行结果的不确定性</li><li>结构性</li></ul></li></ul><h4 id="2、处理机调度"><a href="#2、处理机调度" class="headerlink" title="2、处理机调度"></a>2、处理机调度</h4><h4 id="3、同步与互斥"><a href="#3、同步与互斥" class="headerlink" title="3、同步与互斥"></a>3、同步与互斥</h4><h4 id="4、死锁"><a href="#4、死锁" class="headerlink" title="4、死锁"></a>4、死锁</h4><h2 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h2><h2 id="四、文件管理"><a href="#四、文件管理" class="headerlink" title="四、文件管理"></a>四、文件管理</h2><h2 id="五、输入-输出（IO-管理"><a href="#五、输入-输出（IO-管理" class="headerlink" title="五、输入/输出（IO)管理"></a>五、输入/输出（IO)管理</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 - 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p style="font-size: 150px;text-align:center;color:blue;font-backgrountd:255,255,255">数据结构</p><p>[TOC]</p><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="1-数据结构的基本概念"><a href="#1-数据结构的基本概念" class="headerlink" title="1.数据结构的基本概念"></a>1.数据结构的基本概念</h3><h4 id="1-基本概念和术语"><a href="#1-基本概念和术语" class="headerlink" title="1.基本概念和术语"></a>1.基本概念和术语</h4><p>​    1.数据 </p><p>​        信息的载体,是描述客观事物属性的数,字符及所有能被计算机识别和处理的符号的集合</p><p>​    2.数据元素 </p><p>​        数据的基本单位,由数据项组成,不可分割的最小单位</p><p>​    3.数据对象 </p><p>​        具有相同性质的数据元素的集合,数据的一个子集</p><p>​    4.数据类型 </p><p>​        一个值的集合和定义在集合上的一组操作的总称</p><p>​            原子类型  值不可再分</p><p>​            结构类型  值可以再分</p><p>​            抽象数据类型</p><p>5.抽象数据类型</p><p>​    1.定义: 一个数学模型和定义在模型上的一组操作</p><p>​    2.特点: 定义仅取决于它的一组逻辑特性,与在计算机内部如何表示和实现无关</p><p>​    3.表示: (数据对象,数据关系,基本操作集)</p><p>6.数据结构</p><p>​    1.结构: 数据元素之间的相互关系</p><p>​    2.定义: 相互之间存在一种或多种特定关系的数据元素的集合</p><p>​    3.内容: 逻辑结构,存储结构,数据的运算</p><p>​        逻辑结构: 一个算法的设计</p><p>​        存储结构: 一个算法的实现</p><h4 id="2-数据结构三要素"><a href="#2-数据结构三要素" class="headerlink" title="2.数据结构三要素"></a>2.数据结构三要素</h4><p>1.数据的==逻辑结构==</p><p>​    1.定义: 数据元素之间的逻辑关系,与存储无关,独立于计算机</p><p>​    2.分类</p><ul><li>​        线性结构</li></ul><p>​            1、线性表    一对一</p><ul><li>​        非线性结构</li></ul><p>​            1、集合   同属一个集合</p><p>​            2、树    一对多</p><p>​            3、图/网状    多对多</p><p>2.数据的==存储结构==</p><p>​    1.定义: 数据结构在计算机中的表示(又称映像/物理结构)</p><p>​    2.包括: 数据元素的表示和关系的表示</p><p>​    3.分类</p><ul><li><p>​    ==顺序存储==</p><p>​        优点: 随机存取,元素占用最少存储空间</p><p>​        缺点: 只能使用相邻的一整块存储单元,产生较多的外部碎片</p></li><li><p>​    ==链式存储==</p><p>​        优点: 不会出现碎片现象</p><p>​        缺点: 存储指针占用额外的存储空间; 只能顺序存取</p></li><li><p>​    ==索引存储==</p><p>​        定义: 建立附加的索引表,每项称为索引项(关键字,地址)</p><p>​        优点: 检索速度快</p><p>​        缺点: 占用较多存储空间; 增加和删除数据要修改索引表,花费较多时间</p></li><li><p>​    ==散列存储==</p><p>​        定义: 根据元素的关键字直接计算出该元素的存储地址(Hash存储)</p><p>​        优点: 检索,增加和删除结点都很快</p><p>​        缺点: 若散列函数不好,出现元素存储单元冲突,会增加时间和空间的开销</p></li></ul><p>3.数据的运算</p><p>​    1.运算的定义: 针对逻辑结构,指出运算的功能</p><p>​    2.运算的实现: 针对存储结构,指出运算的具体操作步骤</p><h4 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h4><p>==易错：==</p><p>​        1.属于逻辑结构  有序表</p><p>​        2.循环队列是用顺序表表示的队列,是数据结构,不是抽象数据结构</p><p>​        3.不同结点的存储空间可以不连续,但结点内的存储空间必须连续</p><p>​        4.两种不同的数据结构,逻辑结构和物理结构可以完全相同,但数据的运算不同</p><h3 id="2-算法和算法评价"><a href="#2-算法和算法评价" class="headerlink" title="2.算法和算法评价"></a>2.算法和算法评价</h3><h4 id="1-算法的基本概念"><a href="#1-算法的基本概念" class="headerlink" title="1.算法的基本概念"></a>1.算法的基本概念</h4><p>1.定义: 对特定问题求解步骤的描述,指令的有限序列</p><p>2.==特性==</p><p>​    1.有穷性</p><p>​    2.确定性</p><p>​    3.可行性</p><p>​    4.输入</p><p>​    5.输出</p><p>3.==好的算法==</p><p>​    1.正确性</p><p>​    2.可读性</p><p>​    3.健壮性</p><p>​    4.效率与低存储量需求</p><h4 id="2-算法效率的度量"><a href="#2-算法效率的度量" class="headerlink" title="2.算法效率的度量"></a>2.算法效率的度量</h4><p>1.时间复杂度O(n) </p><p>​    定义: 衡量算法随着问题规模增大,算法执行时间增长的快慢</p><p>2.空间复杂度S(n)</p><p>​    1.定义: 衡量算法随着问题规模增大,算法所需空间增长的快慢</p><p>​    2.算法原地工作: 算法所需要的辅助空间为常数,即O(1)</p><h4 id="题目总结-1"><a href="#题目总结-1" class="headerlink" title="题目总结"></a>题目总结</h4><p>1、==易错==</p><p>​    1.将长度为m,n的两个升序链表,合并为m+n的降序链表(取较小元素,头插法)</p><p>​    2.时间复杂度计算</p><p>​        1.sum += ++i;  O(n^1/2)   第k次: sum = 1+2+3+…+k ≥n</p><p>​        2、2.i=i*2  O(log₂n)</p><p>​        3.递归算法    </p><ul><li>1.T(n)=2T(n/2)+n (n&gt;1) (n=1时: T(n)=1) O(nlog₂n）</li><li>2.设n=2^k,先根据递归条件,找到T(2^k)的通式,再转化为n,即得到时间复杂度</li></ul><p>​    3.同一个算法,实现的语言的级别越高级,执行效率越低</p><hr><h2 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h2><h3 id="1-线性表的定义和基本操作"><a href="#1-线性表的定义和基本操作" class="headerlink" title="1.线性表的定义和基本操作"></a>1.线性表的定义和基本操作</h3><h4 id="1-线性表的定义"><a href="#1-线性表的定义" class="headerlink" title="1.线性表的定义"></a>1.线性表的定义</h4><p>​    1.定义: 相同数据类型的有限序列</p><p>​    2.注意: 线性表是逻辑结构,顺序表和链表指存储结构</p><h4 id="2-线性表的基本操作"><a href="#2-线性表的基本操作" class="headerlink" title="2.线性表的基本操作"></a>2.线性表的基本操作</h4><p>​    1.注意: &amp; 表示C++中的引用,若传入指针型变量且在函数体内要进行改变,要用到指针变量的引用(C中用指针的指针也可以)</p><p>​    2.主要操作</p><h3 id="2-线性表的顺序表示"><a href="#2-线性表的顺序表示" class="headerlink" title="2.线性表的顺序表示"></a>2.线性表的顺序表示</h3><h4 id="1-顺序表的定义"><a href="#1-顺序表的定义" class="headerlink" title="1.顺序表的定义"></a>1.顺序表的定义</h4><p>1.顺序表需要三个部分</p><ul><li>==存储空间的起始位置==</li><li>==顺序表最大存储空间==</li><li>==顺序表当前的长度==</li></ul><p>2.==静态分配==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50 <span class="comment">//定义线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data[MaxSize]; <span class="comment">//顺序表的元素</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//顺序表的当前元素</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.==动态分配==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10 <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;<span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表的类型定义（动态分配方式）</span></span><br></pre></td></tr></table></figure><p>4.动态分配语句</p><p>​    C语言: ==L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);==</p><p>​    C++: ==L.data=new ElemType[InitSize];==</p><p>5.注意: 动态分配不是链式存储,同样属于顺序存储结构,物理结构没有变化:随机存取方式,只是分配的空间大小可以在运行时决定</p><p>6.特点: 随机访问,存储密度高,插入和删除需要移动大量元素</p><h4 id="2-顺序表上基本操作的实现"><a href="#2-顺序表上基本操作的实现" class="headerlink" title="2.顺序表上基本操作的实现"></a>2.顺序表上基本操作的实现</h4><h5 id="1-插入操作-O-n"><a href="#1-插入操作-O-n" class="headerlink" title="1.==插入操作 O(n)=="></a>1.==插入操作 O(n)==</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L.length &gt;= MaxSize) <span class="comment">//当前存储空间已满，不能插入</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; j -- )<span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">L.data[i - <span class="number">1</span>] = e;<span class="comment">//在位置i处放入e</span></span><br><span class="line">L.length ++ ;<span class="comment">//线性表长度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-删除操作-O-n"><a href="#2-删除操作-O-n" class="headerlink" title="2.==删除操作 O(n)=="></a>2.==删除操作 O(n)==</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)<span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e = L.data[i - <span class="number">1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; L.length; j ++ )<span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">L.length -- ;<span class="comment">//线性表长度减1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-按值查找-顺序查找-O-n"><a href="#3-按值查找-顺序查找-O-n" class="headerlink" title="3.==按值查找(顺序查找) O(n)=="></a>3.==按值查找(顺序查找) O(n)==</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, ElemType e)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i ++ )</span><br><span class="line"><span class="keyword">if</span> (L.data[i] == e) </span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;<span class="comment">//下标伟i的元素值等于e，返回其位序i + 1；</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//退出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、-初始化顺序表"><a href="#4、-初始化顺序表" class="headerlink" title="4、==初始化顺序表=="></a>4、==初始化顺序表==</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void InitList(Sqlist &amp;L) &#123;</span><br><span class="line">for (int i = 0; i &lt; MaxSize; i ++ )</span><br><span class="line">L.data[i] = 0;//所有数据元素设置为默认初始值</span><br><span class="line">L.length = 0;//顺序表初始长度为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目总结-2"><a href="#题目总结-2" class="headerlink" title="题目总结"></a>题目总结</h4><p>==1、易错==</p><p>​    1.线性表必须是有限序列</p><p>​    2.在顺序表的第i个位置插入一个数,i的合法取值: 1≤i≤n+1 在第n+1个位置插入相当于在表尾追加</p><p>==2、算法==</p><p><strong>1.将顺序表的所有元素逆序</strong></p><p><font color="blue"> 算法思想：扫描顺序表L的前班部分元素，对于元素L.date[ i ] (0 &lt;= L.length / 2），将其与后半部分的对应元素L.data[L.length - i - 1]进行交换 </font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    ElemType temp;<span class="comment">//辅助变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length / <span class="number">2</span>; i ++ )&#123;</span><br><span class="line">        temp = L.data[i];<span class="comment">//交换L.data[i]与L.data[L.length - i - 1];</span></span><br><span class="line">        L.data[i] = L.data[L.length - i - <span class="number">1</span>];</span><br><span class="line">        L.data[L.length - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.顺序表(非有序)删除所有值为x的数据元素</strong></p><p><font color="blue">用k记录顺序表L中不等于x的元素个数（既需要保存的元素个数），扫描时将不等于x的元素移动到下标k的位置，并更新k值。扫描结束后修改L的长度</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del_x_l</span><span class="params">(SqList &amp;L, Elemtype x)</span>&#123;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>, i;<span class="comment">//记录值不等于x的元素个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i ++ )</span><br><span class="line"><span class="keyword">if</span> (L.data[i] != x)&#123;</span><br><span class="line">L.data[k] = L.data[i];</span><br><span class="line">k ++ ;<span class="comment">//不等于x的元素增1</span></span><br><span class="line">&#125;</span><br><span class="line">L.length = k;<span class="comment">//顺序表L的长度等于k</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.有序顺序表删除给定值s与t之间的所有元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Del_S_t2</span><span class="params">(SqList &amp;L, ElemType s, ElemType t)</span>&#123;</span><br><span class="line"><span class="comment">//删除有序顺序表L中值在给定值s到t之间的所有元素</span></span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= t || L.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">fOr (i = <span class="number">0</span>; i &lt; L.length &amp;&amp; L.data[i] &lt; s; i ++ );<span class="comment">//寻找值大于等于s的第一个元素</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= L.length)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//所有元素值均小于s，返回</span></span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; L.length &amp;&amp; L.data[j] &lt;= t; j ++ )<span class="comment">//寻找值大于t的第一个元素</span></span><br><span class="line"><span class="keyword">for</span> (;j &lt; L.length; i ++ , j ++ )</span><br><span class="line">L.data[i] = L.data[j];<span class="comment">//前移，填补被删元素位置</span></span><br><span class="line">L.length = i;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.有序表删除所有其值重复的元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span>  <span class="title function_">Delete_Same</span><span class="params">(SeqList &amp;L)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> i, j;<span class="comment">//i存储第一个不相同的元素，j为工作指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; L.length; j ++ )</span><br><span class="line"><span class="keyword">if</span> (L.data[i] != L.data[j])<span class="comment">//查找下一个与上个元素值不同的元素</span></span><br><span class="line">L.data[++ i] = L.data[j];<span class="comment">//找到后，将元素前移</span></span><br><span class="line">L.length = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.将两个有序表合并为一个有序表,由函数返回结果</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Merge</span><span class="params">(SeqList A, SeqList B, SeqList &amp;c)</span>&#123;</span><br><span class="line"><span class="comment">//将有序顺序表A与B合并为一个新的有序顺序表C</span></span><br><span class="line"><span class="keyword">if</span> (A.length + B.length &gt; C.maxSize)<span class="comment">//大于顺序表的最大长度</span></span><br><span class="line"><span class="keyword">return</span> fasle;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; A.length &amp;&amp; J &lt; B.length)&#123;<span class="comment">//循环，两两比较，小者存入结构表</span></span><br><span class="line"><span class="keyword">if</span> (A.data[i] &lt; B.data[i])</span><br><span class="line">C.data[k ++ ] = A.data[i ++ ];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">C.data[k ++ ] = B.data[j ++ ];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i &lt; A.length)<span class="comment">//还剩下一个没有比较完的顺序表</span></span><br><span class="line">C.data[k ++ ] = A.data[i ++ ];</span><br><span class="line"><span class="keyword">while</span>(j &lt; B.length)</span><br><span class="line">C.data[k ++ ] = B.data[j ++ ];</span><br><span class="line">C.length = k;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-线性表的链式表示"><a href="#3-线性表的链式表示" class="headerlink" title="3.线性表的链式表示"></a>3.线性表的链式表示</h3><h4 id="1-单链表的定义"><a href="#1-单链表的定义" class="headerlink" title="1.单链表的定义"></a>1.单链表的定义</h4><p>1.结点类型的描述</p><p>2.特点: 浪费空间,非随机存取</p><p>3.头指针和头结点区别</p><p>​        1.不管带不带头结点,头指针始终指向链表的第一个结点</p><p>​        2.头结点是带头结点的链表中的第一个结点,通常不存储信息</p><p>4.引入头结点的优点</p><p>​        1.在链表第一个位置上的操作和其他位置上的一致</p><p>​        2.无论链表是否为空,头指针都指向头结点的非空指针,空表和非空表处理一致    </p><p><strong>单链表定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span><span class="comment">//定义单链表结点类型</span></span><br><span class="line">ElemType data;<span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><h4 id="2-单链表上基本操作的实现"><a href="#2-单链表上基本操作的实现" class="headerlink" title="2.单链表上基本操作的实现"></a>2.单链表上基本操作的实现</h4><p>1.头插法建立链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;<span class="comment">//逆向建立单链表</span></span><br><span class="line">LNode *s; <span class="type">int</span> x;</span><br><span class="line">L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">L.next = <span class="literal">NULL</span>;<span class="comment">//初始化为空链表</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;<span class="comment">//输入9999表示结束</span></span><br><span class="line">s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建新结点</span></span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = s;<span class="comment">//将新的结点插入表中，L为头指针</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.尾插法建立链表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>3.按序号查找结点值</p><p>4.按值查找表结点</p><p>5.插入结点操作</p><p>​        前插操作: 先找到前一个结点,时间复杂度为O(n)</p><p>​        扩展: 将前插操作转化为后插操作,然后交换两个结点的数据,时间复杂度为O(1)</p><p>6.删除结点操作</p><p>​        先找到前驱节点,再删除结点,O(n</p><p>​        扩展: 先和后继结点交换数据,再删除后继结点,O(1)</p><p>7.求表长操作</p><p>​        计算数据结点的个数</p><h4 id="3-双链表"><a href="#3-双链表" class="headerlink" title="3.双链表"></a>3.双链表</h4><p>​    1.双链表中结点类型的描述</p><p>​    2.插入操作</p><p>​    3.删除操作</p><h4 id="4-循环链表"><a href="#4-循环链表" class="headerlink" title="4.循环链表"></a>4.循环链表</h4><p>1.==循环单链表==</p><p>​        1.判空条件: 头结点的指针是否指向头指针</p><p>​        2.对单链表在表头和表尾操作时: 不设头指针仅设尾指针,效率更高</p><p>2.==循环双链表==</p><p>​        判空条件: 头结点的prior域和next域都指向头指针</p><h4 id="5-静态链表"><a href="#5-静态链表" class="headerlink" title="5.静态链表"></a>5.静态链表</h4><p>1.定义: 用数组描述链式存储结构,也有数据域和指针域.指针是结点的相对地址(数组下标),又称游标</p><p>2.形式</p><p>3.结束标志: next==-1</p><p>4.注意</p><p>​        1.和顺序表一样,也要预先分配一块连续的内存空间</p><p>​        2.插入和删除只需要修改指针,不需要移动元素</p><p>​        3.在不支持指针的高级语言(Basic)中很巧妙</p><h4 id="6-顺序表和链表的-比较"><a href="#6-顺序表和链表的-比较" class="headerlink" title="6.顺序表和链表的==比较=="></a>6.顺序表和链表的==比较==</h4><p>1.存取方式</p><p>​        顺序表可顺序存取,可随机存取. 链表只能从表头顺序存取</p><p>2.逻辑结构与物理结构</p><p>3.查找,插入和删除</p><p>​        1.按值查找</p><p>​            无序时,都为O(n)</p><p>​            有序时,顺序表可以折半查找,O(log₂n)</p><p>​        2.按序号查找 </p><p>​            顺序表为O(1),链表为O(n)</p><p>4.空间分配</p><p>5.怎样选取存储结构</p><p>​        1.基于存储的考虑</p><p>​            难以估计长度和存储规模时用链表,但链表的存储密度较低</p><p>​        2.基于运算的考虑</p><p>​            经常做按序号访问数据元素用顺序表</p><p>​        3.基于环境的考虑</p><p>​            顺序表容易实现,链表基于指针</p><p>​            较稳定选顺序表,动态性较强选链表</p><h4 id="题目总结-3"><a href="#题目总结-3" class="headerlink" title="题目总结"></a>题目总结</h4><p>1、==易错==    </p><p>1.链式存储结构比顺序存储结构更方便地表示各种逻辑结构</p><p>2.顺序存储不只能用于存储线性结构,还能存储图和树的结构(满二叉树)</p><p>3.静态链表需要分配较大的连续空间,插入和删除不需要移动元素</p><p>4.若用单链表表示队列,应选用带尾指针的循环链表</p><p>5.给定一维数组,建立一个有序单链表的最低时间为O(nlog₂n) </p><p>​            先对数组进行排序,再构造单链表</p><p>6.链表常用操作为在最后一个元素之后插入,删除第一个元素,最节省时间的是</p><p>​            1.不带头结点且有尾指针的单循环链表</p><p>​            2.即使是双链表,只要不带尾指针,都要找到尾结点,时间为O(n)</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h4 id="1-插入结点时-先对插入结点的后继结点操作-再对原结点进行操作"><a href="#1-插入结点时-先对插入结点的后继结点操作-再对原结点进行操作" class="headerlink" title="1.插入结点时: 先对插入结点的后继结点操作,再对原结点进行操作"></a>1.插入结点时: 先对插入结点的后继结点操作,再对原结点进行操作</h4><h2 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h2><h2 id="第四章-树和二叉树"><a href="#第四章-树和二叉树" class="headerlink" title="第四章 树和二叉树"></a>第四章 树和二叉树</h2><h2 id="第五章-图"><a href="#第五章-图" class="headerlink" title="第五章 图"></a>第五章 图</h2><h2 id="第六章-查找"><a href="#第六章-查找" class="headerlink" title="第六章 查找"></a>第六章 查找</h2><h2 id="第七章-排序"><a href="#第七章-排序" class="headerlink" title="第七章 排序"></a>第七章 排序</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务技术栈</title>
      <link href="/2022/12/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
      <url>/2022/12/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p><span style="text-align:center;font-size:50px;background-color:orange">基础篇</span></p><p><strong>本篇微服务技术栈参考：</strong> <a href="https://www.xn2001.com/archives/663.html">https://www.xn2001.com/archives/663.html</a></p><h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p><strong>单体架构：</strong> 将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="/img/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="单体架构"></p><p><strong>优点：</strong> 架构简单，部署成本低</p><p><strong>缺点：</strong> 耦合度高（维护困难，升级困难）</p><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p><strong>分布式架构：</strong> 根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务</p><p><img src="/img/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84.png" alt="分布式架构"></p><p><strong>优点：</strong> 降低服务耦合，有利于服务升级和扩展</p><p><strong>缺点：</strong> 服务调用关系错综复杂</p><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p><strong>人们需要指定一套行之有效的标准来约束分布式架构。</strong></p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p><strong>微服务的架构特征：</strong></p><ul><li><strong>单一职责：</strong> 微服务拆分粒度更小，每一个服务都对应唯一的业务功能，做到单一职责</li><li><strong>自治：</strong> 团队独立、技术独立、数据独立、独立部署和交付</li><li><strong>面向服务：</strong> 服务提供统一标准的接口，与语言和技术无关</li><li><strong>隔离性强：</strong> 服务调度做和隔离、容错、降级，避免出现级联问题</li></ul><p><img src="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1.png" alt="微服务"></p><p>微服务的上述特性<strong>其实是在给分布式架构指定一个标准</strong>，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p><strong>因此，可以认为微服务是一种经过良好架构设计的分布式架构方案。</strong></p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。<a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></p><h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><p>SpringCloud是目前国内使用最广泛的微服务架构。官网地址：<a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="/img/SpringCloud%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.png" alt="SpringCloud常用组件"></p><p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p><p><img src="/img/SpringCloud%E5%92%8CSpringBoot%E7%9A%84%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E5%85%B3%E7%B3%BB.png" alt="SpringCloud和SpringBoot的版本兼容关系"></p><h3 id="内容知识"><a href="#内容知识" class="headerlink" title="内容知识"></a>内容知识</h3><p><img src="/img/%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9F%A5%E8%AF%86%E5%86%85%E5%AE%B9.png" alt="需要学习的微服务知识内容"></p><p><img src="/img/%E6%8A%80%E6%9C%AF%E6%A0%88.png" alt="技术栈"></p><p><img src="/img/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2.png" alt="自动化部署"></p><h3 id="技术栈对比"><a href="#技术栈对比" class="headerlink" title="技术栈对比"></a>技术栈对比</h3><p><img src="/img/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.png" alt="技术栈对比"></p><h1 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h1><p><strong>服务器拆分注意事项</strong></p><p>单一职责：不同微服务，不要重复开发相同业务</p><p>数据独立：不要访问其他微服务的数据库</p><p>面向服务：将自己的业务暴露为接口，供其他微服务调用</p><p><img src="/img/%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.png" alt="服务拆分注意事项"></p><p>cloude-demo：夫工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有<strong>各自的数据库</strong>，相互独立</li><li>订单服务和用户服务**都对外暴露Restful的接口</li><li>订单服务如果需要查询用户信息，<strong>只能调用用户服务的Restful接口，</strong> 不能查询用户数据库</li></ul><p>微服务项目下，打开IDEA的Service，可以很方便地启动。</p><p><img src="/img/Services.png" alt="Services"></p><p>启动完成后，访问 <a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><p><img src="/img/Services2.png" alt="Services2"></p><h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>服务拆分要求：</p><blockquote><p>订单服务如果需要查询用户信息，<strong>只能调用用户服务的Restful接口</strong>，不能查询用户数据库</p></blockquote><p>因此外卖需要知道Java如何去发送http请求，Spring提供了一个RestTemplate工具，只需要把它创建出来即可。（即注入Bean）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送请求，自动序列化为java对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">    <span class="comment">// 2.利用resttemplate发起http请求，查询用户</span></span><br><span class="line">    <span class="comment">// 2.1 url路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/user/&quot;</span> + order.getUserId();</span><br><span class="line">    <span class="comment">// 2.2 发起http请求，实现远程调用</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">    <span class="comment">// 3.封装user到order</span></span><br><span class="line">    order.setUser(user);</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动完成后，访问：<a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><p><img src="/img/Service3.png" alt="启动完成后"></p><p>在上面代码的url中，我们可以发现调用服务的地址采用硬编码，这在后续的开发中肯定是不理想的，这就需要<strong>服务注册中心（Eureka）</strong> 来帮我们解决这个事情。</p><h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><h2 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h2><p>最广为人知的注册中心就是Eureka，其结构如下：<br><img src="/img/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="Eureka注册中心"></p><p><strong>order-service如何得知user-service实例地址？</strong> </p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-service（Eureka服务端），也叫<strong>服务注册</strong></li><li>eureka-server保存服务名称到服务实例地址列表的映射关系</li><li>order-service根据服务名称，拉取实例地址列表，这个叫<strong>服务发现</strong>或服务拉取</li></ul><p><strong>order-service如何从多个user-service实例中选择具体的实例？</strong></p><p>order-service从实例列表中利用<strong>负载均衡算法</strong>选中一个实例地址，向该实例地址发起远程调用</p><p><strong>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</strong></p><ul><li>user-service会<strong>每隔一段时间（默认30秒）向eureka-server发起请求</strong>，报告自己状态，称为<strong>心跳</strong></li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service拉取请求时，就能将故障实例排除了</li></ul><p>接下来我们动手实践的步骤包括</p><p><img src="/img/Eureka%E6%B3%A8%E5%86%8C%E6%AD%A5%E9%AA%A4.png" alt="Eureka注册步骤"></p><h2 id="搭建注册中心"><a href="#搭建注册中心" class="headerlink" title="搭建注册中心"></a>搭建注册中心</h2><p><strong>1、搭建eureka-server</strong></p><p>引入SpringCloud为eureka提供的starter依赖，注意这里是用<strong>server</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>2、编写启动类</strong></p><p>注意要添加一个<font color="red">@EnableEurekaServer</font><strong>注解</strong>，开启eureka的<strong>注册中心</strong>功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xn2001.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、编写配置文件</strong></p><p>编写一个application.yml文件，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line"> port: <span class="number">10086</span></span><br><span class="line">spring:</span><br><span class="line"> application:</span><br><span class="line">  name: eureka-server</span><br><span class="line">eureka:</span><br><span class="line"> client:</span><br><span class="line">  service-url:</span><br><span class="line">   defaultZone: http:<span class="comment">//127.0.0.1::10086/eureka</span></span><br></pre></td></tr></table></figure><p>其中<code>default-zone</code>是因为前面配置类开启了注册中心所需要配置的eureka的<strong>地址信息</strong>，因为eureka本事也是一个微服务，这里也要将自己注册起来，当后面eureka<strong>集群</strong>时，这里就可以填写多个，使用“ ；”隔开。</p><p>启动完成后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><img src="/img/Eureka%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F%E7%95%8C%E9%9D%A2.png" alt="Eureka启动成功界面"></p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><blockquote><p>将user-service、order-service都注册到eureka</p></blockquote><p>引入SpringCloud为eureka提供的starter依赖，注意这里是用<strong>client</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在启动类上添加注解：<code>@EnableEurekaClient</code></p><p>在application.yml文件，添加下面的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> application:</span><br><span class="line">  name: userservice</span><br><span class="line">eureka:</span><br><span class="line"> client:</span><br><span class="line">  service-url:</span><br><span class="line">   defaultZone: http:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>/eureka</span><br></pre></td></tr></table></figure><p>3个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><img src="/img/Eureka%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F%E7%95%8C%E9%9D%A22.png" alt="Eureka启动成功界面"></p><p>这里另外再补充个小技巧，我们可以通过 idea 的多实例启动，来查看 Eureka 的集群效果。</p><p><img src="/img/IDEA%E5%A4%9A%E5%AE%9E%E4%BE%8B%E8%B0%83%E8%AF%95.png" alt="IDEA多实例调试"></p><p>4个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><img src="/img/Eureka4%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8.png" alt="Eureka4项目启动"></p><h2 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h2><blockquote><p>在order-service中完成服务拉取，然后通过负载均衡挑选一个服务，实践远程调用</p></blockquote><p>下面我们让 order-service 向 eureka-server 拉取 user-service 的信息，实现服务发现。</p><p>首先给 <code>RestTemplate</code> 这个 Bean 添加一个 <code>@LoadBalanced</code> <strong>注解</strong>，用于开启<strong>负载均衡</strong>。（后面会讲）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改orderService访问的url路径，用<strong>服务名</strong>代替ip、端口</p><p><img src="/img/%E4%BF%AE%E6%94%B9Eureka%E7%9A%84url%E8%B7%AF%E5%BE%84.png" alt="修改Eureka的url路径"></p><p>spring会自动帮助我们从eureka-server中，根据uservice这个服务名称，获取实例列表后去完成负载均衡。</p><h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><p>我们添加了<code>@LoalBalanced</code>注解，即可实现负载均衡功能，这是什么原理呢？</p><p><strong>SpringCloud底层提供了一个名为Ribbon的组件，来实现负载均衡功能</strong></p><p><img src="/img/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="Ribbon负载均衡"></p><p><strong>1、源码跟踪</strong><br>为什么我们只输入了service名称就可以访问了呢？为什么不需要获取ip和端口，这显然有人帮我们根据service名称，获取到了服务实例的ip和端口，他就是<code>LoadBalancerInterceptor</code>，这个类会对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后根据负载均衡算法得到真实的服务地址信息，替换服务id。</p><p>我们进行源码跟踪：</p><p><img src="/img/Interceptor%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA.png" alt="Interceptor源码跟踪"></p><p>这里的<code>intercept()</code>方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURL()</code>：获取请求uri，即<a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>:获取uri路径的主机名，其实就是服务id<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求</li></ul><p>这里的<code>this.loadBalancer.execute()</code>：处理服务id和请求</p><p>继续跟人<code>execute()</code>方法：</p><p><img src="/img/%E8%B7%9F%E8%BF%9Bexecute()%E6%96%B9%E6%B3%95.png" alt="跟进execute()方法"></p><ul><li><p><code>getLoadBalancer(serviceId)</code>：根据服务id获取</p><p><code>IloadBalancer</code>，而<code>ILoadBancer</code>会拿着服务id去eureka中获取服务列表</p></li><li><p><code>getServer(loadBalancer)</code>：利用内置的负载均衡算法，从服务列表中选择一个。在图中<strong>可以看到获取了8082端口的服务</strong></p></li></ul><p>可以看到获取服务时，通过一个<code>getServer()</code>方法来做负载均衡：</p><p><img src="/img/getServer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="getServer负载均衡"></p><p>我们继续跟入：</p><p><img src="/img/%E7%BB%A7%E7%BB%AD%E8%B7%9F%E5%85%A5.png" alt="继续跟入"></p><p>继续跟踪源码 <code>chooseServer()</code> 方法，发现这么一段代码：</p><p>![跟踪源码 chooseServer()方法](/img/跟踪源码 chooseServer()方法.png)</p><p>我们看看这个 <code>rule</code> 是谁：</p><p><img src="/img/rule.png" alt="rule"></p><p>这里的 rule 默认值是一个 <code>RoundRobinRule</code> ，看类的介绍：</p><p><img src="/img/rule%E9%BB%98%E8%AE%A4%E5%80%BC.png" alt="rule默认值"></p><p>负载均衡默认使用了轮训算法，当然我们也可以自定义。</p><p><strong>2、流程总结</strong></p><p>SpringCloud Ribbon 底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。</p><p>基本流程如下：</p><ul><li>拦截我们的 <code>RestTemplate</code> 请求 <a href="http://userservice/user/1">http://userservice/user/1</a></li><li><code>RibbonLoadBalancerClient</code> 会从请求url中获取服务名称，也就是 user-service</li><li><code>DynamicServerListLoadBalancer</code> 根据 user-service 到 eureka 拉取服务列表</li><li>eureka 返回列表，localhost:8081、localhost:8082</li><li><code>IRule</code> 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li><li><code>RibbonLoadBalancerClient</code> 修改请求地址，用 localhost:8081 替代 userservice，得到 <a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><p><img src="/img/robbon%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93.png" alt="robbon流程总结"></p><p><strong>3、负载均衡策略</strong></p><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p><p><img src="/img/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5.png" alt="负载均衡策略"></p><p>不同规则的含义如下：</p><table><thead><tr><th align="left"><strong>内置负载均衡规则类</strong></th><th align="left"><strong>规则描述</strong></th></tr></thead><tbody><tr><td align="left">RoundRobinRule</td><td align="left">简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td align="left">AvailabilityFilteringRule</td><td align="left">对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。</td></tr><tr><td align="left">WeightedResponseTimeRule</td><td align="left">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td align="left"><strong>ZoneAvoidanceRule</strong></td><td align="left">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td align="left">BestAvailableRule</td><td align="left">忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td align="left">RandomRule</td><td align="left">随机选择一个可用的服务器。</td></tr><tr><td align="left">RetryRule</td><td align="left">重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是 <code>ZoneAvoidanceRule</code>，<strong>是一种轮询方案</strong>。</p><p><strong>4、自定义策略</strong></p><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p><p>1 代码方式在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</p><p><img src="/img/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AD%96%E7%95%A5.png" alt="自定义策略"></p><p>2 配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice: # 给需要调用的微服务配置负载均衡规则，orderservice服务去调用userservice服务</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：一般用默认的负载均衡规则，不做修改。</p><p><strong>5、饥饿加载</strong></p><p>当我们启动 orderservice，第一次访问时，时间消耗会大很多，这是因为 Ribbon 懒加载的机制。</p><p><img src="/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE.png" alt="/img/第一次访问.png"></p><p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，拉取集群地址，所以请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建 LoadBalanceClient，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line"> eager-load:</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">   clients: userservice # 项目启动时直接去拉取userservice的集群，多个用<span class="string">&quot;,&quot;</span>隔开</span><br></pre></td></tr></table></figure><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><p>SpringCloudAlibaba 推出了一个名为 Nacos 的注册中心，在国外也有大量的使用。</p><p><img src="/img/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="Nacos注册中心"></p><p>解压启动Nacos，详细请看<a href="https://www.xn2001.com/archives/661.html">Nacos安装指南</a></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单机启动</span></span><br><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:8848/nacos/">http://localhost:8848/nacos/</a></p><p><img src="/img/Nacos%E5%90%AF%E5%8A%A8.png" alt="Nacos启动"></p><p><strong>1、服务注册</strong></p><p>这里上来就直接服务注册，很多东西可能有疑惑，其实 Nacos 本身就是一个 SprintBoot 项目，这点你从启动的控制台打印就可以看出来，所以就不再需要去额外搭建一个像 Eureka 的注册中心。</p><p><strong>引入依赖</strong></p><p>在 cloud-demo 父工程中引入 SpringCloudAlibaba 的依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.6</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后在 user-service 和 order-service 中的pom文件中引入 nacos-discovery 依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>配置nacos地址</strong></p><p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> cloud:</span><br><span class="line">  nacos:</span><br><span class="line">   server-addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8848</span></span><br></pre></td></tr></table></figure><p>项目重新启动后，可以看到三个服务都被注册进了 Nacos</p><p><img src="/img/Nacos%E6%B3%A8%E5%86%8C.png" alt="Nacos注册"></p><p>浏览器访问：<a href="http://localhost:8080/order/101%EF%BC%8C%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%9F%E6%AD%A3%E5%B8%B8%E3%80%82">http://localhost:8080/order/101，正常访问，同时负载均衡也正常。</a></p><h2 id="分级存储模型"><a href="#分级存储模型" class="headerlink" title="分级存储模型"></a>分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例，划分为一个<strong>集群</strong>。</p><p><img src="/img/Nacos%E9%9B%86%E7%BE%A4.png" alt="Nacos集群"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。<strong>当本集群内不可用时，才访问其它集群。</strong>例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。</p><p><img src="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9B%86%E7%BE%A4%E8%AE%BF%E9%97%AE.png" alt="微服务集群访问"></p><p><strong>配置集群</strong></p><p>接下来我们给 user-service <strong>配置集群</strong></p><p>修改 user-service 的 application.yml 文件，添加集群配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> cloud:</span><br><span class="line">  nacos:</span><br><span class="line">   server-addr: localhost:<span class="number">8848</span></span><br><span class="line">   discovery:</span><br><span class="line">    cluster-name: HZ # 集群名称 HZ杭州</span><br></pre></td></tr></table></figure><p>重启两个 user-service 实例后，我们再去启动一个上海集群的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dserver.port=<span class="number">8083</span> -Dspring.cloud.nacos.discovery.cluster-name=SH</span><br></pre></td></tr></table></figure><p><img src="/img/%E5%86%8D%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%9B%86%E7%BE%A4%E5%AE%9E%E4%BE%8B.png" alt="再次启动集群实例"></p><p>查看 nacos 控制台</p><p><img src="/img/%E6%9F%A5%E7%9C%8Bnacos%E6%8E%A7%E5%88%B6%E5%8F%B0.png" alt="查看nacos控制台"></p><h2 id="NacosRule"><a href="#NacosRule" class="headerlink" title="NacosRule"></a>NacosRule</h2><p>Ribbon的默认实现 <code>ZoneAvoidanceRule</code> 并不能实现根据同集群优先来实现负载均衡，我们把规则改成 <strong>NacosRule</strong> 即可。我们是用 orderservice 调用 userservice，所以在 orderservice 配置规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">iRule</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//默认为轮询规则，这里自定义为随机规则</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，你同样可以使用配置的形式来完成，具体参考上面的 Ribbon 栏目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice:</span><br><span class="line"> ribbon:</span><br><span class="line">  NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule #负载均衡规则 </span><br></pre></td></tr></table></figure><p>然后，再对 orderservice 配置集群。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> cloud:</span><br><span class="line">  nacos:</span><br><span class="line">   server-addr: localhost:<span class="number">8848</span></span><br><span class="line">   discovery:</span><br><span class="line">    cluster-name: HZ # 集群名称</span><br></pre></td></tr></table></figure><p>现在我启动了四个服务，分别是：</p><ul><li>orderservice - HZ</li><li>userservice - HZ</li><li>userservice1 - HZ</li><li>userservice2 - SH</li></ul><p>访问地址：<a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><p>在访问中我们发现，只有同在一个 HZ 集群下的 userservice、userservice1 会被调用，并且是随机的。</p><p>我们试着把 userservice、userservice2 停掉。依旧可以访问。</p><p>在 userservice3 控制台可以看到发出了一串的警告，因为 orderservice 本身是在 HZ 集群的，这波 HZ 集群没有了 userservice，就会去别的集群找。</p><p><img src="/img/nacos%E9%9B%86%E7%BE%A4%E8%AD%A6%E5%91%8A.png" alt="nacos集群警告"></p><h2 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos 提供了<strong>权重配置来控制访问频率</strong>，0~1 之间，权重越大则访问频率越高，权重修改为 0，则该实例永远不会被访问。</p><p>在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重。</p><p><img src="/img/nacos%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE.png" alt="nacos权限配置"></p><p>在弹出的编辑窗口，修改权重</p><p><img src="/img/nacos%E4%BF%AE%E6%94%B9%E6%9D%83%E9%87%8D.png" alt="nacos修改权重"></p><p>另外，在服务升级的时候，有一种较好的方案：我们也可以通过调整权重来进行平滑升级，例如：先把 userservice 权重调节为 0，让用户先流向 userservice2、userservice3，升级 userservice后，再把权重从 0 调到 0.1，让一部分用户先体验，用户体验稳定后就可以往上调权重啦。</p><h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p><ul><li>Nacos 中可以有多个 namespace</li><li>namespace 下可以有 group、service 等</li><li>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</li></ul><p><img src="/img/%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB.png" alt="环境隔离"></p><p><strong>1、创建namespace</strong></p><p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public(保留空间)：</p><p><img src="/img/%E5%88%9B%E5%BB%BAnamespace.png" alt="创建namespace"></p><p>我们可以点击页面新增按钮，添加一个 namespace：</p><p><img src="/img/%E6%B7%BB%E5%8A%A0namespace.png" alt="添加namespace"></p><p>然后，填写表单：</p><p><img src="/img/%E5%A1%AB%E5%86%99%E8%A1%A8%E5%8D%95.png" alt="填写表单"></p><p>就能在页面看到一个新的 namespace：</p><p><img src="/img/%E6%96%B0%E7%9A%84namespace.png" alt="新的namespace"></p><p><strong>2、配置namespace</strong></p><p>给微服务配置 namespace 只能通过修改配置来实现。</p><p>例如，修改 order-service 的 application.yml 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> cloud:</span><br><span class="line">  nacos:</span><br><span class="line">   server-addr: localhost:<span class="number">8848</span></span><br><span class="line">   discovery:</span><br><span class="line">    cluster-name: HZ</span><br><span class="line">    namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间ID</span><br></pre></td></tr></table></figure><p>重启 order-service 后，访问控制台。</p><p><strong>public</strong></p><p><img src="/img/public.png" alt="public"></p><p><strong>dev</strong></p><p><img src="/img/dev.png" alt="dev"></p><p>此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：</p><p><img src="/img/%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%8A%A5%E9%94%99.png" alt="控制台报"></p><h2 id="临时实例"><a href="#临时实例" class="headerlink" title="临时实例"></a>临时实例</h2><p>Nacos 的服务实例分为两种类型：</p><ul><li><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</li><li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> cloud:</span><br><span class="line">  nacos:</span><br><span class="line">   discovery:</span><br><span class="line">    ephemeral: <span class="literal">false</span> # 设置为非临时实例</span><br></pre></td></tr></table></figure><p>另外，Nacos 集群**默认采用AP方式(可用性)<strong>，当集群中存在非临时实例时，</strong>采用CP模式(一致性)**；而 Eureka 采用AP方式，不可切换。（这里说的是 CAP 原理，后面会写到）</p><h2 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h2><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。<strong>我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</strong></p><p><img src="/img/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.png" alt="Nacos配置中心"></p><p><strong>创建配置</strong></p><p>在 Nacos 控制面板中添加配置文件</p><p><img src="/img/%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="添加配置文件"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="/img/%E5%A1%AB%E5%86%99%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.png" alt="填写配置信息"></p><p><strong>注意</strong>：项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置(例如数据库连接)还是保存在微服务本地比较好。</p><p><strong>拉取配置</strong></p><p>首先我们需要了解 Nacos 读取配置文件的环节是在哪一步，在没加入 Nacos 配置之前，获取配置是这样：</p><p><img src="/img/%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE.png" alt="获取配置"></p><p>加入 Nacos 配置，它的读取是在 application.yml 之前的：</p><p><img src="/img/%E5%8A%A0%E5%85%A5Nacos%E9%85%8D%E7%BD%AE%E5%90%8E.png" alt="加入Nacos配置后"></p><p>这时候如果把 nacos 地址放在 application.yml 中，显然是不合适的，<strong>Nacos 就无法根据地址去获取配置了。</strong></p><p>因此，nacos 地址必须放在优先级最高的 bootstrap.yml 文件。</p><p><img src="/img/bootstrapyml.png" alt="bootstrap.yml"></p><p><strong>引入 nacos-config 依赖</strong></p><p>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--nacos配置管理依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>添加 bootstrap.yml</strong></p><p>然后，在 user-service 中添加一个 bootstrap.yml 文件，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: userservice # 服务名称</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev #开发环境，这里是dev </span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:<span class="number">8848</span> # Nacos地址</span><br><span class="line">      config:</span><br><span class="line">        file-extension: yaml # 文件后缀名</span><br></pre></td></tr></table></figure><p>根据 spring.cloud.nacos.server-addr 获取 nacos地址，再根据<code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>在这个例子例中，就是去读取 <code>userservice-dev.yaml</code></p><p><img src="/img/nacos%E9%85%8D%E7%BD%AE%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB.png" alt="nacos配置映射关系"></p><p>使用代码来验证是否拉取成功</p><p>在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置并使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String dateformat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//格式化时间</span></span><br><span class="line">    <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81.png" alt="代码验证"></p><p>启动服务后，访问：<a href="http://localhost:8081/user/now">http://localhost:8081/user/now</a></p><p><img src="/img/%E5%90%AF%E5%8A%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="启动示意图"></p><h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><p>其实在服务启动时，nacos 会读取多个配置文件，例如：</p><ul><li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li><li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li></ul><p>这里的 <code>[spring.application.name].yaml</code> 不包含环境，<strong>因此可以被多个环境共享</strong>。</p><p><strong>添加一个环境共享配置</strong></p><p>我们在 nacos 中添加一个 userservice.yaml 文件：</p><p><img src="/img/%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE.png" alt="添加一个环境共享配置"></p><p><strong>在 user-service 中读取共享配置</strong></p><p>在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：</p><p><img src="/img/%E8%AF%BB%E5%8F%96%E6%96%B0%E6%B7%BB%E5%8A%A0%E7%9A%84%E5%B1%9E%E6%80%A7.png" alt="读取新添加的属性"></p><p>在 user-service 服务中，修改 UserController，添加一个方法：</p><p><img src="/img/%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95.png" alt="添加一个方法"></p><p><strong>运行两个 UserApplication，使用不同的profile</strong></p><p>修改 UserApplication2 这个启动项，改变其profile值：</p><p><img src="/img/%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84profile.png" alt="使用不同的profile"></p><p><img src="/img/%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84profile2.png" alt="使用不同的profile2"></p><p>这样，UserApplication(8081) 使用的 profile 是 dev，UserApplication2(8082) 使用的 profile 是test</p><p>启动 UserApplication 和 UserApplication2</p><p>访问地址：<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p><p><img src="/img/%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%9C1.png" alt="使用不同的配置结果"></p><p>访问地址：<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p><p><img src="/img/%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%9C2.png" alt="使用不同的配置结果"></p><p>可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。</p><p>上面的都是同一个微服务下，<strong>那么不同微服务之间可以环境共享吗？</strong></p><p>通过下面的两种方式来指定：</p><ul><li>extension-configs</li><li>shared-configs</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      config:</span><br><span class="line">        file-extension: yaml # 文件后缀名</span><br><span class="line">        extends-configs: # 多微服务间共享的配置列表</span><br><span class="line">          - dataId: common.yaml # 要共享的配置文件id</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      config:</span><br><span class="line">        file-extension: yaml # 文件后缀名</span><br><span class="line">        shared-configs: # 多微服务间共享的配置列表</span><br><span class="line">          - dataId: common.yaml # 要共享的配置文件id</span><br></pre></td></tr></table></figure><p><strong>配置优先级</strong></p><p>当 nacos、服务本地同时<strong>出现相同属性时</strong>，优先级有高低之分。</p><p><img src="/img/%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%89%E9%AB%98%E4%BD%8E%E4%B9%8B%E5%88%86.png" alt="优先级有高低之分"></p><p>更细致的配置</p><p><img src="/img/%E6%9B%B4%E7%BB%86%E8%87%B4%E7%9A%84%E9%85%8D%E7%BD%AE.png" alt="更细致的配置"></p><h2 id="Nacos集群"><a href="#Nacos集群" class="headerlink" title="Nacos集群"></a>Nacos集群</h2><p><strong>架构介绍</strong></p><p><img src="/img/%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D.png" alt="架构介绍"></p><p>其中包含 3 个Nacos 节点，然后一个负载均衡器 Nginx 代理 3 个 Nacos，我们计划的 Nacos 集群如下图，MySQL 的主从复制后续再添加。</p><p><img src="/img/%E8%AE%A1%E5%88%92%E7%9A%84Nacos%E9%9B%86%E7%BE%A4.png" alt="计划的Nacos集群"></p><p>三个 Nacos 节点的地址</p><table><thead><tr><th align="left">节点</th><th align="left">ip</th><th align="left">port</th></tr></thead><tbody><tr><td align="left">nacos1</td><td align="left">192.168.150.1</td><td align="left">8845</td></tr><tr><td align="left">nacos2</td><td align="left">192.168.150.1</td><td align="left">8846</td></tr><tr><td align="left">nacos3</td><td align="left">192.168.150.1</td><td align="left">8847</td></tr></tbody></table><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>Nacos 默认数据存储在内嵌数据库 Derby 中，不属于生产可用的数据库。官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库。这里我们以单点的数据库为例。</p><p>首先新建一个数据库，命名为 nacos，而后导入下面的 SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `config_info` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(255) DEFAULT NULL,</span><br><span class="line">  `content` longtext NOT NULL COMMENT &#x27;content&#x27;,</span><br><span class="line">  `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `src_user` text COMMENT &#x27;source user&#x27;,</span><br><span class="line">  `src_ip` varchar(50) DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span><br><span class="line">  `app_name` varchar(128) DEFAULT NULL,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  `c_desc` varchar(256) DEFAULT NULL,</span><br><span class="line">  `c_use` varchar(64) DEFAULT NULL,</span><br><span class="line">  `effect` varchar(64) DEFAULT NULL,</span><br><span class="line">  `type` varchar(64) DEFAULT NULL,</span><br><span class="line">  `c_schema` text,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;;</span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = config_info_aggr   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `config_info_aggr` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(255) NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `datum_id` varchar(255) NOT NULL COMMENT &#x27;datum_id&#x27;,</span><br><span class="line">  `content` longtext NOT NULL COMMENT &#x27;内容&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `app_name` varchar(128) DEFAULT NULL,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;增加租户字段&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = config_info_beta   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `config_info_beta` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span><br><span class="line">  `content` longtext NOT NULL COMMENT &#x27;content&#x27;,</span><br><span class="line">  `beta_ips` varchar(1024) DEFAULT NULL COMMENT &#x27;betaIps&#x27;,</span><br><span class="line">  `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `src_user` text COMMENT &#x27;source user&#x27;,</span><br><span class="line">  `src_ip` varchar(50) DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_beta&#x27;;</span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = config_info_tag   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `config_info_tag` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span><br><span class="line">  `tag_id` varchar(128) NOT NULL COMMENT &#x27;tag_id&#x27;,</span><br><span class="line">  `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span><br><span class="line">  `content` longtext NOT NULL COMMENT &#x27;content&#x27;,</span><br><span class="line">  `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `src_user` text COMMENT &#x27;source user&#x27;,</span><br><span class="line">  `src_ip` varchar(50) DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_tag&#x27;;</span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = config_tags_relation   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `config_tags_relation` (</span><br><span class="line">  `id` bigint(20) NOT NULL COMMENT &#x27;id&#x27;,</span><br><span class="line">  `tag_name` varchar(128) NOT NULL COMMENT &#x27;tag_name&#x27;,</span><br><span class="line">  `tag_type` varchar(64) DEFAULT NULL COMMENT &#x27;tag_type&#x27;,</span><br><span class="line">  `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span><br><span class="line">  `nid` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  PRIMARY KEY (`nid`),</span><br><span class="line">  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_tag_relation&#x27;;</span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = group_capacity   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `group_capacity` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,</span><br><span class="line">  `group_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Group ID，空字符表示整个集群&#x27;,</span><br><span class="line">  `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;,</span><br><span class="line">  `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;,</span><br><span class="line">  `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数，，0表示使用默认值&#x27;,</span><br><span class="line">  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;集群、各Group容量信息表&#x27;;</span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = his_config_info   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `his_config_info` (</span><br><span class="line">  `id` bigint(64) unsigned NOT NULL,</span><br><span class="line">  `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `data_id` varchar(255) NOT NULL,</span><br><span class="line">  `group_id` varchar(128) NOT NULL,</span><br><span class="line">  `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span><br><span class="line">  `content` longtext NOT NULL,</span><br><span class="line">  `md5` varchar(32) DEFAULT NULL,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `src_user` text,</span><br><span class="line">  `src_ip` varchar(50) DEFAULT NULL,</span><br><span class="line">  `op_type` char(10) DEFAULT NULL,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  PRIMARY KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;多租户改造&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = tenant_capacity   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `tenant_capacity` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Tenant ID&#x27;,</span><br><span class="line">  `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;,</span><br><span class="line">  `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;,</span><br><span class="line">  `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数&#x27;,</span><br><span class="line">  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;租户容量信息表&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE `tenant_info` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `kp` varchar(128) NOT NULL COMMENT &#x27;kp&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span><br><span class="line">  `tenant_name` varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_name&#x27;,</span><br><span class="line">  `tenant_desc` varchar(256) DEFAULT NULL COMMENT &#x27;tenant_desc&#x27;,</span><br><span class="line">  `create_source` varchar(32) DEFAULT NULL COMMENT &#x27;create_source&#x27;,</span><br><span class="line">  `gmt_create` bigint(20) NOT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` bigint(20) NOT NULL COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;tenant_info&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `users` (</span><br><span class="line">    `username` varchar(50) NOT NULL PRIMARY KEY,</span><br><span class="line">    `password` varchar(500) NOT NULL,</span><br><span class="line">    `enabled` boolean NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `roles` (</span><br><span class="line">    `username` varchar(50) NOT NULL,</span><br><span class="line">    `role` varchar(50) NOT NULL,</span><br><span class="line">    UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `permissions` (</span><br><span class="line">    `role` varchar(50) NOT NULL,</span><br><span class="line">    `resource` varchar(255) NOT NULL,</span><br><span class="line">    `action` varchar(8) NOT NULL,</span><br><span class="line">    UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO users (username, password, enabled) VALUES (&#x27;nacos&#x27;, &#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;, TRUE);</span><br><span class="line"></span><br><span class="line">INSERT INTO roles (username, role) VALUES (&#x27;nacos&#x27;, &#x27;ROLE_ADMIN&#x27;);</span><br></pre></td></tr></table></figure><p><strong>配置Nacos</strong></p><p>进入 nacos 的 conf 目录，修改配置文件 cluster.conf.example，重命名为 cluster.conf</p><p><img src="/img/%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="修改配置文件"></p><p>添加内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8845</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="number">.8846</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="number">.8847</span></span><br></pre></td></tr></table></figure><p>然后修改 application.properties 文件，添加数据库配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line">db.num=<span class="number">1</span></span><br><span class="line">db.url<span class="number">.0</span>=jdbc:mysql:<span class="comment">//127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line">db.user<span class="number">.0</span>=root</span><br><span class="line">db.password<span class="number">.0</span>=<span class="number">123456</span></span><br></pre></td></tr></table></figure><p>将 nacos 文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="/img/%E5%B0%86nacos%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%8D%E5%88%B6%E4%B8%89%E4%BB%BD.png" alt="将nacos文件夹复制三份"></p><p>然后分别修改三个文件夹中的 application.properties，</p><p>nacos1</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8845</span></span><br></pre></td></tr></table></figure><p>nacos2</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8846</span></span><br></pre></td></tr></table></figure><p>nacos3</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8847</span></span><br></pre></td></tr></table></figure><p>然后分别启动三个 nacos</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd</span><br></pre></td></tr></table></figure><p><strong>Nginx反向代理</strong></p><p>修改 nginx 文件夹下的 conf/nginx.conf 文件，配置如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> nacos-cluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8845</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8846</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8847</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /nacos &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://nacos-cluster;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 nginx，在浏览器访问：<a href="http://localhost/nacos">http://localhost/nacos</a></p><p>在代码中的 application.yml 文件配置改为如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:80</span> <span class="comment"># Nacos地址</span></span><br></pre></td></tr></table></figure><p>实际部署时，需要给做反向代理的 Nginx 服务器设置一个域名，这样后续如果有服务器迁移 Nacos 的客户端也无需更改配置。Nacos 的各个节点应该部署到多个不同服务器，做好容灾和隔离工作。</p><h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><p>我们以前利用 RestTemplate 发起远程调用的代码：</p><p><img src="/img/%E5%88%A9%E7%94%A8RestTemplate%E5%8F%91%E8%B5%B7%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8.png" alt="利用RestTemplate发起远程调用"></p><ul><li>代码可读性差，编程体验不统一</li><li>参数复杂URL难以维护</li></ul><p>Feign 是一个声明式的 http 客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们<strong>优雅的实现 http 请求的发送</strong>，解决上面提到的问题。</p><p><img src="/img/feign%E4%BD%9C%E7%94%A8.png" alt="feign作用"></p><h2 id="Feign使用"><a href="#Feign使用" class="headerlink" title="Feign使用"></a>Feign使用</h2><p><strong>引入依赖</strong></p><p>我们在 order-service 引入 feign 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>添加注解</strong></p><p>在 order-service 启动类添加注解开启 Feign</p><p><img src="/img/%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%90%AFFeign.png" alt="注解开启Feign"></p><p><strong>请求接口</strong></p><p>在 order-service 中新建一个接口，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xn2001.order.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xn2001.order.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@FeignClient(&quot;userservice&quot;)</code>：其中参数填写的是微服务名</p><p><code>@GetMapping(&quot;/user/&#123;id&#125;&quot;)</code>：其中参数填写的是请求路径</p><p>这个客户端主要是基于 SpringMVC 的注解 <code>@GetMapping</code> 来声明远程调用的信息</p><p>Feign 可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</p><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderAndUserById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 2021/8/20 使用feign远程调用</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.findById(order.getUserId());</span><br><span class="line">    <span class="comment">// 3. 将用户信息封装进订单</span></span><br><span class="line">    order.setUser(user);</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>Feign 可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th align="left">类型</th><th align="left">作用</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>feign.Logger.Level</strong></td><td align="left">修改日志级别</td><td align="left">包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td align="left">feign.codec.Decoder</td><td align="left">响应结果的解析器</td><td align="left">http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td align="left">feign.codec.Encoder</td><td align="left">请求参数编码</td><td align="left">将请求参数编码，便于通过http请求发送</td></tr><tr><td align="left">feign.Contract</td><td align="left">支持的注解格式</td><td align="left">默认是SpringMVC的注解</td></tr><tr><td align="left">feign.Retryer</td><td align="left">失败重试机制</td><td align="left">请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 @Bean 覆盖默认 Bean 即可。下面以日志为例来演示如何自定义配置。</p><p>基于配置文件修改 feign 的日志级别可以针对单个服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">userservice:</span> <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p><strong>也可以针对所有服务</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据</li></ul><p>也可以基于 <strong>Java 代码</strong>来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfiguration</span>  &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要<strong>全局生效</strong>，将其放到启动类的 <code>@EnableFeignClients</code> 这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><p>如果是<strong>局部生效</strong>，则把它放到对应的 <code>@FeignClient</code> 这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现有：</p><ul><li><strong>URLConnection</strong>：默认实现，不支持连接池</li><li><strong>Apache HttpClient</strong> ：支持连接池</li><li><strong>OKHttp</strong>：支持连接池</li></ul><p>因此提高 Feign 性能的主要手段就是使用<strong>连接池</strong>代替默认的 URLConnection</p><p>另外，日志级别应该尽量用 basic/none，可以有效提高性能。</p><p><strong>这里我们用 Apache 的HttpClient来演示连接池。</strong></p><p>在 order-service 的 pom 文件中引入 HttpClient 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置连接池</strong></p><p>在 order-service 的 application.yml 中添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure><p>在 FeignClientFactoryBean 中的 loadBalance 方法中打断点</p><p><img src="/img/loadBalance.png" alt="loadBalance"></p><p>Debug 方式启动 order-service 服务，可以看到这里的 client，底层就是 HttpClient</p><p><img src="/img/HttpClient.png" alt="HttpClient"></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p><strong>继承方式</strong></p><p>一样的代码可以通过继承来共享：</p><p>1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明</p><p>2）Feign 客户端、Controller 都集成该接口</p><p><img src="/img/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.png" alt="最佳实践"></p><p>优点</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点</p><ul><li>服务提供方、服务消费方紧耦合</li><li>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</li></ul><p><strong>抽取方式</strong></p><p>将 FeignClient 抽取为独立模块，并且把接口有关的 pojo、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p><p>例如：将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="/img/%E6%8A%BD%E5%8F%96%E6%96%B9%E5%BC%8F.png" alt="抽取方式"></p><p>接下来我们就用该方法在代码中实现</p><p><strong>首先创建一个 module，命名为 feign-api</strong></p><p><img src="/img/feign-api.png" alt="feign-api"></p><p>在 feign-api 中然后引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>order-service中 的 UserClient、User 都复制到 feign-api 项目中</p><p><img src="/img/feign-api%E4%BF%AE%E6%94%B9.png" alt="feign-api修改"></p><p>接下来在 order-service 中使用 feign-api</p><p>由于我们已经将 UserClient、User 放在 fegin-api 中共享了 ，所以可以删除 order-service 中的 UserClient、User，然后在 order-service 中引入 feign-api</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xn2001.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>修改注解</strong></p><p>当定义的 FeignClient 不在 SpringBootApplication 的扫描包范围下时，这些 FeignClient 就不能使用。</p><p>修改 order-service 启动类上的 <code>@EnableFeignClients</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.xn2001.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure><h1 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><p>Gateway 网关是我们服务的守门神，<strong>所有微服务的统一入口。</strong></p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p><img src="/img/Gateway%E7%BD%91%E5%85%B3.png" alt="Gateway网关"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在 SpringCloud 中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul 是基于 Servlet 实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring5 中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><ol><li>创建 SpringBoot 工程 gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建 application.yml 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>上面的例子中，我们将 <code>/user/**</code> 开头的请求，代理到 <code>lb://userservice</code>，其中 lb 是负载均衡(LoadBalance)，根据服务名拉取服务列表，实现负载均衡。</p><p>重启网关，访问 <a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a> 时，符合 <code>/user/**</code> 规则，请求转发到 uri：<a href="http://userservice/user/1">http://userservice/user/1</a></p><p><img src="/img/httpuserserviceuser1.png" alt="httpuserserviceuser1"></p><p>多个 predicates 的话，要同时满足规则，下文有例子。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/img/gateway%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="gateway流程图"></p><p>路由配置包括：</p><ol><li>路由id：路由的唯一标示</li><li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li><li>路由断言（predicates）：判断路由的规则</li><li>路由过滤器（filters）：对请求或响应做处理</li></ol><h2 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件。</p><p>例如 <code>Path=/user/**</code> 是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code> 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个</p><table><thead><tr><th align="left">名称</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">- Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie=chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header=X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host（域名）</td><td align="left">- Host=<code>**.somehost.org</code>, <code>**.anotherhost.org</code></td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method=GET,POST</td></tr><tr><td align="left">Path</td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path=/red/{segment},/blue/**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query=name, Jack或者- Query=name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr=192.168.1.1/24</td></tr><tr><td align="left">Weight</td><td align="left">权重处理</td><td align="left"></td></tr></tbody></table><blockquote><p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p></blockquote><p>一般的，我们只需要掌握 Path，加上官方文档的例子，就可以应对各种工作场景了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">After=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>像这样的规则，现在是 2021年8月22日01:32:42，很明显 After 条件不满足，可以不会转发，路由不起作用。</p><h2 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h2><p>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p><p><img src="/img/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82.png" alt="过滤器工厂"></p><p>Spring提供了31种不同的路由过滤器工厂。</p><blockquote><p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p></blockquote><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">AddRequestHeader</td><td align="left">给当前请求添加一个请求头</td></tr><tr><td align="left">RemoveRequestHeader</td><td align="left">移除请求中的一个请求头</td></tr><tr><td align="left">AddResponseHeader</td><td align="left">给响应结果中添加一个响应头</td></tr><tr><td align="left">RemoveResponseHeader</td><td align="left">从响应结果中移除有一个响应头</td></tr><tr><td align="left">RequestRateLimiter</td><td align="left">限制请求的流量</td></tr></tbody></table><p>下面我们以 AddRequestHeader 为例：</p><p><img src="/img/AddRequestHeader.png" alt="AddRequestHeader"></p><p><strong>需求</strong>：给所有进入 userservice 的请求添加一个请求头：<code>sign=xn2001.com is eternal</code></p><p>只需要修改 gateway 服务的 application.yml文件，添加路由过滤即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=sign,</span> <span class="string">xn2001.com</span> <span class="string">is</span> <span class="string">eternal</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure><p>如何验证，我们修改 userservice 中的一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="meta">@RequestHeader(value = &quot;sign&quot;, required = false)</span> String sign)</span> &#123;</span><br><span class="line">    log.warn(sign);</span><br><span class="line">    <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启两个服务，访问：<a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a></p><p>可以看到控制台打印出了这个请求头</p><p><img src="/img/%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="控制台打印请求头"></p><h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>上面介绍的过滤器工厂，网关提供了 31 种，但每一种过滤器的作用都是固定的。<strong>如果我们希望拦截请求，做自己的业务逻辑则没办法实现</strong>。</p><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，<strong>与 GatewayFilter 的作用一样</strong>。区别在于 GlobalFilter 的逻辑可以<strong>写代码来自定义规则</strong>；而 GatewayFilter 通过配置定义，处理逻辑是固定的。</p><p><strong>需求</strong>：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件</p><ul><li>参数中是否有 authorization</li><li>authorization 参数值是否为 admin</li></ul><p>如果同时满足则放行，否则拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试：http://localhost:10010/order/101?authorization=admin</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取第一个 authorization 参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(authorization))&#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置拦截状态码信息</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="comment">// 设置拦截</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置过滤器优先级，值越低优先级越高</span></span><br><span class="line">    <span class="comment">// 也可以使用 @Order 注解</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤器顺序"><a href="#过滤器顺序" class="headerlink" title="过滤器顺序"></a>过滤器顺序</h2><p>请求进入网关会碰到三类过滤器：DefaultFilter、当前路由的过滤器、GlobalFilter；</p><p>请求路由后，会将三者合并到一个过滤器链（集合）中，排序后依次执行每个过滤器.</p><p><img src="/img/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%A1%BA%E5%BA%8F.png" alt="过滤器顺序"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个 int 类型的 order 值，<strong>order 值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter 通过实现 Ordered 接口，或者使用 @Order 注解来指定 order 值，由我们自己指定。</li><li>路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从1递增。</li><li>当过滤器的 order 值一样时，<strong>会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。</strong></li></ul><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>不了解跨域问题的同学可以百度了解一下；在 Gateway 网关中解决跨域问题还是比较方便的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 allowedOrigins: “*” 允许所有网站</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><p><span style="text-align:center;font-size:50px;background-color:orange">高级篇</span></p><h1 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h1><h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><h1 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h1>]]></content>
      
      
      <categories>
          
          <category> 微服务技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Eureka </tag>
            
            <tag> Nacos </tag>
            
            <tag> Feign </tag>
            
            <tag> Gateway </tag>
            
            <tag> Docker </tag>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> SpringAMQP </tag>
            
            <tag> ES </tag>
            
            <tag> RestClient </tag>
            
            <tag> DSL </tag>
            
            <tag> Seata </tag>
            
            <tag> Redis </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/2022/12/10/Mysql/"/>
      <url>/2022/12/10/Mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><h2 id="1，数据库相关概念"><a href="#1，数据库相关概念" class="headerlink" title="1，数据库相关概念"></a>1，数据库相关概念</h2><p>以前我们做系统，数据持久化的存储采用的是文件存储。存储到文件中可以达到系统关闭数据不会丢失的效果，当然文件存储也有它的弊端。</p><p>假设在文件中存储以下的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名年龄性别住址</span><br><span class="line">张三23男北京西三旗</span><br><span class="line">李四24女北京西二旗</span><br><span class="line">王五25男西安软件新城</span><br></pre></td></tr></table></figure><p>现要修改李四这条数据的性别数据改为男，我们现学习的IO技术可以通过将所有的数据读取到内存中，然后进行修改再存到该文件中。通过这种方式操作存在很大问题，现在只有三条数据，如果文件中存储1T的数据，那么就会发现内存根本就存储不了。</p><p>现需要既能持久化存储数据，也要能避免上述问题的技术使用在我们的系统中。数据库就是这样的一门技术。</p><h3 id="1-1-数据库"><a href="#1-1-数据库" class="headerlink" title="1.1  数据库"></a>1.1  数据库</h3><ul><li><p>存储和管理数据的仓库，数据是有组织的进行存储。</p></li><li><p>数据库英文名是 DataBase，简称DB。</p></li></ul><p>数据库就是将数据存储在硬盘上，可以达到持久化存储的效果。那又是如何解决上述问题的？使用数据库管理系统。</p><h3 id="1-2-数据库管理系统"><a href="#1-2-数据库管理系统" class="headerlink" title="1.2  数据库管理系统"></a>1.2  数据库管理系统</h3><ul><li>管理数据库的大型软件</li><li>英文：DataBase Management System，简称 DBMS</li></ul><p>在电脑上安装了数据库管理系统后，就可以通过数据库管理系统创建数据库来存储数据，也可以通过该系统对数据库中的数据进行数据的增删改查相关的操作。我们平时说的MySQL数据库其实是MySQL数据库管理系统。</p><p>通过上面的描述，大家应该已经知道了 <code>数据库管理系统</code> 和 <code>数据库</code> 的关系。那么有有哪些常见的数据库管理系统呢？</p><h3 id="1-3-常见的数据库管理系统"><a href="#1-3-常见的数据库管理系统" class="headerlink" title="1.3  常见的数据库管理系统"></a>1.3  常见的数据库管理系统</h3><p>接下来对上面列举的数据库管理系统进行简单的介绍：</p><ul><li>Oracle：收费的大型数据库，Oracle 公司的产品</li><li>MySQL： 开源免费的中小型数据库。后来 Sun公司收购了 MySQL，而 Sun 公司又被 Oracle 收购</li><li>SQL Server：MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用</li><li>PostgreSQL：开源免费中小型的数据库</li><li>DB2：IBM 公司的大型收费数据库产品</li><li>SQLite：嵌入式的微型数据库。如：作为 Android 内置数据库</li><li>MariaDB：开源免费中小型的数据库</li></ul><p>我们课程上学习的是MySQL数据库管理系统，PostgreSQL在一些公司也有使用，此时大家肯定会想以后在公司中如果使用我们没有学习过程的PostgreSQL数据库管理系统怎么办？这点大家大可不必担心，如下图所示：</p><p>我们可以通过数据库管理系统操作数据库，对数据库中的数据进行增删改查操作，而怎么样让用户跟数据库管理系统打交道呢？就可以通过一门编程语言（SQL）来实现。</p><h3 id="1-4-SQL"><a href="#1-4-SQL" class="headerlink" title="1.4  SQL"></a>1.4  SQL</h3><ul><li>英文：Structured Query Language，简称 SQL，结构化查询语言</li><li>操作关系型数据库的编程语言</li><li>定义操作所有关系型数据库的统一标准，可以使用SQL操作所有的关系型数据库管理系统，以后工作中如果使用到了其他的数据库管理系统，也同样的使用SQL来操作。</li></ul><h2 id="2，MySQL"><a href="#2，MySQL" class="headerlink" title="2，MySQL"></a>2，MySQL</h2><h3 id="2-1-MySQL安装"><a href="#2-1-MySQL安装" class="headerlink" title="2.1  MySQL安装"></a>2.1  MySQL安装</h3><blockquote><p><strong>安装环境:Win10 64位</strong><br><strong>软件版本:MySQL 5.7.24 解压版</strong></p></blockquote><h4 id="2-1-1-下载"><a href="#2-1-1-下载" class="headerlink" title="2.1.1  下载"></a>2.1.1  下载</h4><p><a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p><p>点开上面的链接就能看到如下界面：</p><p>选择选择和自己<strong>系统位数</strong>相对应的版本点击右边的<code>Download</code>，此时会进到另一个页面，同样在接近页面底部的地方找到如下图所示的位置：</p><p>不用理会上面的登录和注册按钮，直接点击 <code>No thanks, just start my download.</code> 就可以下载。</p><h4 id="2-1-2-安装-解压"><a href="#2-1-2-安装-解压" class="headerlink" title="2.1.2  安装(解压)"></a>2.1.2  安装(解压)</h4><p>下载完成后我们得到的是一个压缩包，将其解压，我们就可以得到MySQL 5.7.24的软件本体了(就是一个文件夹)，我们可以把它放在你想安装的位置。</p><h3 id="2-2-MySQL卸载"><a href="#2-2-MySQL卸载" class="headerlink" title="2.2  MySQL卸载"></a>2.2  MySQL卸载</h3><p>如果你想卸载MySQL，也很简单。</p><p>右键开始菜单，选择<code>命令提示符(管理员)</code>，打开黑框。</p><ol><li>敲入<code>net stop mysql</code>，回车。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure><ol start="2"><li>再敲入<code>mysqld -remove mysql</code>，回车。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -remove mysql</span><br></pre></td></tr></table></figure><ol start="3"><li>最后删除MySQL目录及相关的环境变量。</li></ol><p><strong>至此，MySQL卸载完成！</strong></p><h3 id="2-3-MySQL配置"><a href="#2-3-MySQL配置" class="headerlink" title="2.3  MySQL配置"></a>2.3  MySQL配置</h3><h4 id="2-3-1-添加环境变量"><a href="#2-3-1-添加环境变量" class="headerlink" title="2.3.1  添加环境变量"></a>2.3.1  添加环境变量</h4><blockquote><p>环境变量里面有很多选项，这里我们只用到<code>Path</code>这个参数。为什么在初始化的开始要添加环境变量呢？<br>在黑框(即CMD)中输入一个可执行程序的名字，Windows会先在环境变量中的<code>Path</code>所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用MySQL中的相关程序而不用总是修改工作目录，大大简化了操作。</p></blockquote><p>右键<code>此电脑</code>→<code>属性</code>，点击<code>高级系统设置</code></p><p>点击<code>环境变量</code></p><p>在<code>系统变量</code>中新建MYSQL_HOME</p><p>在<code>系统变量</code>中找到并<strong>双击</strong><code>Path</code></p><p>点击<code>新建</code></p><p>最后点击确定。</p><p><strong>如何验证是否添加成功？</strong></p><p>右键开始菜单(就是屏幕左下角)，选择<code>命令提示符(管理员)</code>，打开黑框，敲入<code>mysql</code>，回车。<br>如果提示<code>Can&#39;t connect to MySQL server on &#39;localhost&#39;</code>则证明添加成功；<br>如果提示<code>mysql不是内部或外部命令，也不是可运行的程序或批处理文件</code>则表示添加添加失败，请重新检查步骤并重试。</p><h4 id="2-3-2-新建配置文件"><a href="#2-3-2-新建配置文件" class="headerlink" title="2.3.2  新建配置文件"></a>2.3.2  新建配置文件</h4><p>新建一个文本文件，内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=<span class="string">utf8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">character-set-server</span>=<span class="string">utf8</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=<span class="string">INNODB</span></span><br><span class="line"><span class="attr">sql_mode</span>=<span class="string">STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span></span><br></pre></td></tr></table></figure><p>把上面的文本文件另存为，在保存类型里选<code>所有文件 (*.*)</code>，文件名叫<code>my.ini</code>，存放的路径为MySQL的<code>根目录</code>(例如我的是<code>D:\software\mysql-5.7.24-winx64</code>,根据自己的MySQL目录位置修改)。</p><p>上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。</p><h4 id="2-3-3-初始化MySQL"><a href="#2-3-3-初始化MySQL" class="headerlink" title="2.3.3  初始化MySQL"></a>2.3.3  初始化MySQL</h4><p>在刚才的黑框中敲入<code>mysqld --initialize-insecure</code>，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize-insecure</span><br></pre></td></tr></table></figure><p>tips：如果出现如下错误</p><p>是由于权限不足导致的，去<code>C:\Windows\System32</code> 下以管理员方式运行 cmd.exe</p><p><img src="H:\BaiDuWangPan\JavaWeb\day01-MySQL基础\ppt\assets\image-20201109140001186.png" alt="image-20201109140001186"></p><h4 id="2-3-4-注册MySQL服务"><a href="#2-3-4-注册MySQL服务" class="headerlink" title="2.3.4  注册MySQL服务"></a>2.3.4  注册MySQL服务</h4><p>在黑框里敲入<code>mysqld -install</code>，回车。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -install</span><br></pre></td></tr></table></figure><p>现在你的计算机上已经安装好了MySQL服务了。</p><p>MySQL服务器</p><h4 id="2-3-5-启动MySQL服务"><a href="#2-3-5-启动MySQL服务" class="headerlink" title="2.3.5  启动MySQL服务"></a>2.3.5  启动MySQL服务</h4><p>在黑框里敲入<code>net start mysql</code>，回车。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net start mysql  <span class="comment">// 启动mysql服务</span></span><br><span class="line">    </span><br><span class="line">net stop mysql  <span class="comment">// 停止mysql服务</span></span><br></pre></td></tr></table></figure><h4 id="2-3-6-修改默认账户密码"><a href="#2-3-6-修改默认账户密码" class="headerlink" title="2.3.6  修改默认账户密码"></a>2.3.6  修改默认账户密码</h4><p>在黑框里敲入<code>mysqladmin -u root password 1234</code>，这里的<code>1234</code>就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root password 1234</span><br></pre></td></tr></table></figure><p><strong>至此，MySQL 5.7 解压版安装完毕！</strong></p><h3 id="2-4-MySQL登陆和退出"><a href="#2-4-MySQL登陆和退出" class="headerlink" title="2.4  MySQL登陆和退出"></a>2.4  MySQL登陆和退出</h3><h4 id="2-4-1-登陆"><a href="#2-4-1-登陆" class="headerlink" title="2.4.1  登陆"></a>2.4.1  登陆</h4><p>右键开始菜单，选择<code>命令提示符</code>，打开黑框。<br>在黑框中输入，<code>mysql -uroot -p1234</code>，回车，出现下图且左下角为<code>mysql&gt;</code>，则登录成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p1234</span><br></pre></td></tr></table></figure><p><strong>到这里你就可以开始你的MySQL之旅了！</strong></p><p>登陆参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306)</span><br></pre></td></tr></table></figure><h4 id="2-4-2-退出"><a href="#2-4-2-退出" class="headerlink" title="2.4.2  退出"></a>2.4.2  退出</h4><p>退出mysql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><h3 id="2-5-MySQL数据模型"><a href="#2-5-MySQL数据模型" class="headerlink" title="2.5  MySQL数据模型"></a>2.5  MySQL数据模型</h3><p><strong>关系型数据库：</strong></p><blockquote><p>关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能互相连接的 二维表 组成的数据库</p></blockquote><p>如下图，<code>订单信息表</code> 和 <code>客户信息表</code> 都是有行有列二维表我们将这样的称为关系型数据库。</p><p>接下来看关系型数据库的优点：</p><ul><li>都是使用表结构，格式一致，易于维护。</li><li>使用通用的 SQL 语言操作，使用方便，可用于复杂查询。<ul><li>关系型数据库都可以通过SQL进行操作，所以使用方便。</li><li>复杂查询。现在需要查询001号订单数据，我们可以看到该订单是1号客户的订单，而1号订单是李聪这个客户。以后也可以在一张表中进行统计分析等操作。</li></ul></li><li>数据存储在磁盘中，安全。</li></ul><p><strong>数据模型：</strong></p><p>如上图，我们通过客户端可以通过数据库管理系统创建数据库，在数据库中创建表，在表中添加数据。创建的每一个数据库对应到磁盘上都是一个文件夹。比如可以通过SQL语句创建一个数据库（数据库名称为db1），语句如下。该语句咱们后面会学习。</p><p>我们可以在数据库安装目录下的data目录下看到多了一个 <code>db1</code> 的文件夹。所以，<strong>在MySQL中一个数据库对应到磁盘上的一个文件夹。</strong></p><p>而一个数据库下可以创建多张表，我们到MySQL中自带的mysql数据库的文件夹目录下：</p><p>而上图中右边的 <code>db.frm</code> 是表文件，<code>db.MYD</code> 是数据文件，通过这两个文件就可以查询到数据展示成二维表的效果。</p><p><strong>小结：</strong></p><ul><li>MySQL中可以创建多个数据库，每个数据库对应到磁盘上的一个文件夹</li><li>在每个数据库中可以创建多个表，每张都对应到磁盘上一个 frm 文件</li><li>每张表可以存储多条数据，数据会被存储到磁盘中  MYD 文件中</li></ul><h2 id="3，SQL概述"><a href="#3，SQL概述" class="headerlink" title="3，SQL概述"></a>3，SQL概述</h2><p>了解了数据模型后，接下来我们就学习SQL语句，通过SQL语句对数据库、表、数据进行增删改查操作。 </p><h3 id="3-1-SQL简介"><a href="#3-1-SQL简介" class="headerlink" title="3.1  SQL简介"></a>3.1  SQL简介</h3><ul><li>英文：Structured Query Language，简称 SQL</li><li>结构化查询语言，一门操作关系型数据库的编程语言</li><li>定义操作所有关系型数据库的统一标准</li><li>对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”</li></ul><h3 id="3-2-通用语法"><a href="#3-2-通用语法" class="headerlink" title="3.2  通用语法"></a>3.2  通用语法</h3><ul><li><p>SQL 语句可以单行或多行书写，以分号结尾。 </p><p>如上，以分号结尾才是一个完整的sql语句。</p></li><li><p>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</p><p>同样的一条sql语句写成下图的样子，一样可以运行处结果。</p></li><li><p>注释</p><ul><li><p>单行注释: – 注释内容 或 #注释内容(MySQL 特有)  </p><blockquote><p>注意：使用– 添加单行注释时，–后面一定要加空格，而#没有要求。</p></blockquote></li><li><p>多行注释: /* 注释 */</p></li></ul></li></ul><h3 id="3-3-SQL分类"><a href="#3-3-SQL分类" class="headerlink" title="3.3  SQL分类"></a>3.3  SQL分类</h3><ul><li><p>DDL(Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等</p><p>DDL简单理解就是用来操作数据库，表等</p></li><li><p>DML(Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改</p><p>DML简单理解就对表中数据进行增删改</p></li><li><p>DQL(Data Query Language) 数据查询语言，用来查询数据库中表的记录(数据)</p><p>DQL简单理解就是对数据进行查询操作。从数据库表中查询到我们想要的数据。</p></li><li><p>DCL(Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户</p><p>DML简单理解就是对数据库进行权限控制。比如我让某一个数据库表只能让某一个用户进行操作等。</p></li></ul><blockquote><p>注意： 以后我们最常操作的是 <code>DML</code> 和 <code>DQL</code>  ，因为我们开发中最常操作的就是数据。</p></blockquote><h2 id="4，DDL-操作数据库"><a href="#4，DDL-操作数据库" class="headerlink" title="4，DDL:操作数据库"></a>4，DDL:操作数据库</h2><p>我们先来学习DDL来操作数据库。而操作数据库主要就是对数据库的增删查操作。</p><h3 id="4-1-查询"><a href="#4-1-查询" class="headerlink" title="4.1  查询"></a>4.1  查询</h3><p>查询所有的数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure><p>运行上面语句效果如下：</p><p>上述查询到的是的这些数据库是mysql安装好自带的数据库，我们以后不要操作这些数据库。</p><h3 id="4-2-创建数据库"><a href="#4-2-创建数据库" class="headerlink" title="4.2  创建数据库"></a>4.2  创建数据库</h3><ul><li><strong>创建数据库</strong>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名称;</span><br></pre></td></tr></table></figure><p>运行语句效果如下：</p><p>而在创建数据库的时候，我并不知道db1数据库有没有创建，直接再次创建名为db1的数据库就会出现错误。</p><p>为了避免上面的错误，在创建数据库的时候先做判断，如果不存在再创建。</p><ul><li><strong>创建数据库(判断，如果不存在则创建)</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名称;</span><br></pre></td></tr></table></figure><p>运行语句效果如下：</p><p>从上面的效果可以看到虽然db1数据库已经存在，再创建db1也没有报错，而创建db2数据库则创建成功。</p><h3 id="4-3-删除数据库"><a href="#4-3-删除数据库" class="headerlink" title="4.3  删除数据库"></a>4.3  删除数据库</h3><ul><li><strong>删除数据库</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名称;</span><br></pre></td></tr></table></figure><ul><li><strong>删除数据库(判断，如果存在则删除)</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> 数据库名称;</span><br></pre></td></tr></table></figure><p>运行语句效果如下：</p><h3 id="4-4-使用数据库"><a href="#4-4-使用数据库" class="headerlink" title="4.4  使用数据库"></a>4.4  使用数据库</h3><p>数据库创建好了，要在数据库中创建表，得先明确在哪儿个数据库中操作，此时就需要使用数据库。</p><ul><li><strong>使用数据库</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名称;</span><br></pre></td></tr></table></figure><ul><li><strong>查看当前使用的数据库</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure><p>运行语句效果如下：</p><h2 id="5，DDL-操作表"><a href="#5，DDL-操作表" class="headerlink" title="5，DDL:操作表"></a>5，DDL:操作表</h2><p>操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。</p><h3 id="5-1-查询表"><a href="#5-1-查询表" class="headerlink" title="5.1  查询表"></a>5.1  查询表</h3><ul><li><strong>查询当前数据库下所有表名称</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p>我们创建的数据库中没有任何表，因此我们进入mysql自带的mysql数据库，执行上述语句查看</p><ul><li><strong>查询表结构</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表名称;</span><br></pre></td></tr></table></figure><p>查看mysql数据库中func表的结构，运行语句如下：</p><h3 id="5-2-创建表"><a href="#5-2-创建表" class="headerlink" title="5.2  创建表"></a>5.2  创建表</h3><ul><li><strong>创建表</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">字段名<span class="number">1</span>  数据类型<span class="number">1</span>,</span><br><span class="line">字段名<span class="number">2</span>  数据类型<span class="number">2</span>,</span><br><span class="line">…</span><br><span class="line">字段名n  数据类型n</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：最后一行末尾，不能加逗号</p></blockquote><p>知道了创建表的语句，那么我们创建创建如下结构的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user (</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    password <span class="type">varchar</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>运行语句如下：</p><h3 id="5-3-数据类型"><a href="#5-3-数据类型" class="headerlink" title="5.3  数据类型"></a>5.3  数据类型</h3><p>MySQL 支持多种类型，可以分为三类：</p><ul><li><p>数值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tinyint : 小整数型，占一个字节</span><br><span class="line"><span class="type">int</span>： 大整数类型，占四个字节</span><br><span class="line">eg ： age <span class="type">int</span></span><br><span class="line"><span class="keyword">double</span> ： 浮点类型</span><br><span class="line">使用格式： 字段名 <span class="keyword">double</span>(总长度,小数点后保留的位数)</span><br><span class="line">eg ： score <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>)   </span><br></pre></td></tr></table></figure></li><li><p>日期</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">date</span> ： 日期值。只包含年月日</span><br><span class="line">eg ：birthday <span class="type">date</span> ： </span><br><span class="line">datetime ： 混合日期和时间值。包含年月日时分秒</span><br></pre></td></tr></table></figure></li><li><p>字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ： 定长字符串。</span><br><span class="line">优点：存储性能高</span><br><span class="line">缺点：浪费空间</span><br><span class="line">eg ： name <span class="type">char</span>(<span class="number">10</span>)  如果存储的数据字符个数不足<span class="number">10</span>个，也会占<span class="number">10</span>个的空间</span><br><span class="line"><span class="type">varchar</span> ： 变长字符串。</span><br><span class="line">优点：节约空间</span><br><span class="line">缺点：存储性能底</span><br><span class="line">eg ： name <span class="type">varchar</span>(<span class="number">10</span>) 如果存储的数据字符个数不足<span class="number">10</span>个，那就数据字符个数是几就占几个的空间</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：其他类型参考资料中的《MySQL数据类型].xlsx》</p></blockquote><p><strong>案例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">需求：设计一张学生表，请注重数据类型、长度的合理性</span><br><span class="line">1. 编号</span><br><span class="line">2. 姓名，姓名最长不超过10个汉字</span><br><span class="line">3. 性别，因为取值只有两种可能，因此最多一个汉字</span><br><span class="line">4. 生日，取值为年月日</span><br><span class="line">5. 入学成绩，小数点后保留两位</span><br><span class="line">6. 邮件地址，最大长度不超过 64</span><br><span class="line">7. 家庭联系电话，不一定是手机号码，可能会出现 - 等字符</span><br><span class="line">8. 学生状态（用数字表示，正常、休学、毕业...）</span><br></pre></td></tr></table></figure><p>语句设计如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student (</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">    birthday <span class="type">date</span>,</span><br><span class="line">    score <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">    email <span class="type">varchar</span>(<span class="number">15</span>),</span><br><span class="line">    tel <span class="type">varchar</span>(<span class="number">15</span>),</span><br><span class="line">    status tinyint</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="5-4-删除表"><a href="#5-4-删除表" class="headerlink" title="5.4  删除表"></a>5.4  删除表</h3><ul><li><strong>删除表</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure><ul><li><strong>删除表时判断表是否存在</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> 表名;</span><br></pre></td></tr></table></figure><p>运行语句效果如下：</p><h3 id="5-5-修改表"><a href="#5-5-修改表" class="headerlink" title="5.5  修改表"></a>5.5  修改表</h3><ul><li><strong>修改表名</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新的表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将表名student修改为stu</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student rename <span class="keyword">to</span> stu;</span><br></pre></td></tr></table></figure><ul><li><strong>添加一列</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 列名 数据类型;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给stu表添加一列address，该字段类型是varchar(50)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">add</span> address <span class="type">varchar</span>(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>修改数据类型</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 列名 新数据类型;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将stu表中的address字段的类型改为 char(50)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu modify address <span class="type">char</span>(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>修改列名和数据类型</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 列名 新列名 新数据类型;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将stu表中的address字段名改为 addr，类型改为varchar(50)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu change address addr <span class="type">varchar</span>(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>删除列</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 列名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将stu表中的addr字段 删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">drop</span> addr;</span><br></pre></td></tr></table></figure><h2 id="6，navicat使用"><a href="#6，navicat使用" class="headerlink" title="6，navicat使用"></a>6，navicat使用</h2><p>通过上面的学习，我们发现在命令行中写sql语句特别不方便，尤其是编写创建表的语句，我们只能在记事本上写好后直接复制到命令行进行执行。那么有没有刚好的工具提供给我们进行使用呢？ 有。</p><h3 id="6-1-navicat概述"><a href="#6-1-navicat概述" class="headerlink" title="6.1  navicat概述"></a>6.1  navicat概述</h3><ul><li>Navicat for MySQL 是管理和开发 MySQL 或 MariaDB 的理想解决方案。</li><li>这套全面的前端工具为数据库管理、开发和维护提供了一款直观而强大的图形界面。</li><li>官网： <a href="http://www.navicat.com.cn/">http://www.navicat.com.cn</a> </li></ul><h3 id="6-2-navicat安装"><a href="#6-2-navicat安装" class="headerlink" title="6.2  navicat安装"></a>6.2  navicat安装</h3><p>参考 : 资料\navicat安装包\navicat_mysql_x86\navicat安装步骤.md</p><h3 id="6-3-navicat使用"><a href="#6-3-navicat使用" class="headerlink" title="6.3  navicat使用"></a>6.3  navicat使用</h3><h4 id="6-3-1-建立和mysql服务的连接"><a href="#6-3-1-建立和mysql服务的连接" class="headerlink" title="6.3.1  建立和mysql服务的连接"></a>6.3.1  建立和mysql服务的连接</h4><p>第一步： 点击连接，选择MySQL</p><p>第二步：填写连接数据库必要的信息</p><p>以上操作没有问题就会出现如下图所示界面：</p><h4 id="6-3-2-操作"><a href="#6-3-2-操作" class="headerlink" title="6.3.2  操作"></a>6.3.2  操作</h4><p>连接成功后就能看到如下图界面：</p><ul><li><strong>修改表结构</strong></li></ul><p>通过下图操作修改表结构：</p><p>点击了设计表后即出现如下图所示界面，在图中红框中直接修改字段名，类型等信息：</p><ul><li><strong>编写SQL语句并执行</strong></li></ul><p>按照如下图所示进行操作即可书写SQL语句并执行sql语句。</p><h2 id="7，DML"><a href="#7，DML" class="headerlink" title="7，DML"></a>7，DML</h2><p>DML主要是对数据进行增（insert）删（delete）改（update）操作。</p><h3 id="7-1-添加数据"><a href="#7-1-添加数据" class="headerlink" title="7.1  添加数据"></a>7.1  添加数据</h3><ul><li><strong>给指定列添加数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,…) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…);</span><br></pre></td></tr></table></figure><ul><li><strong>给全部列添加数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…);</span><br></pre></td></tr></table></figure><ul><li><strong>批量添加数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,…) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…)…;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…)…;</span><br></pre></td></tr></table></figure><ul><li><strong>练习</strong></li></ul><p>为了演示以下的增删改操作是否操作成功，故先将查询所有数据的语句介绍给大家：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给指定列添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu (id, NAME) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="comment">-- 给所有列添加数据，列名的列表可以省略的</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu (id,NAME,sex,birthday,score,email,tel,STATUS) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 批量添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="7-2-修改数据"><a href="#7-2-修改数据" class="headerlink" title="7.2  修改数据"></a>7.2  修改数据</h3><ul><li><strong>修改表数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,列名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,… [<span class="keyword">WHERE</span> 条件] ;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>修改语句中如果不加条件，则将所有数据都修改！</li><li>像上面的语句中的中括号，表示在写sql语句中可以省略这部分</li></ol></blockquote><ul><li><p><strong>练习</strong></p><ul><li><p>将张三的性别改为女</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> stu <span class="keyword">set</span> sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>将张三的生日改为 1999-12-12 分数改为99.99</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> stu <span class="keyword">set</span> birthday <span class="operator">=</span> <span class="string">&#x27;1999-12-12&#x27;</span>, score <span class="operator">=</span> <span class="number">99.99</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>注意：如果update语句没有加where条件，则会将表中所有数据全部修改！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> stu <span class="keyword">set</span> sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面语句的执行完后查询到的结果是：</p></li></ul></li></ul><h3 id="7-3-删除数据"><a href="#7-3-删除数据" class="headerlink" title="7.3  删除数据"></a>7.3  删除数据</h3><ul><li><strong>删除数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] ;</span><br></pre></td></tr></table></figure><ul><li><strong>练习</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除张三记录</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除stu表中所有的数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><h2 id="8，DQL"><a href="#8，DQL" class="headerlink" title="8，DQL"></a>8，DQL</h2><p>下面是黑马程序员展示试题库数据的页面</p><p>页面上展示的数据肯定是在数据库中的试题库表中进行存储，而我们需要将数据库中的数据查询出来并展示在页面给用户看。上图中的是最基本的查询效果，那么数据库其实是很多的，不可能在将所有的数据在一页进行全部展示，而页面上会有分页展示的效果，如下：</p><p><img src="H:\BaiDuWangPan\JavaWeb\day01-MySQL基础\ppt\assets\image-20210722220139174.png" alt="image-20210722220139174"></p><p>当然上图中的难度字段当我们点击也可以实现排序查询操作。从这个例子我们就可以看出，对于数据库的查询时灵活多变的，需要根据具体的需求来实现，而数据库查询操作也是最重要的操作，所以此部分需要大家重点掌握。</p><p>接下来我们先介绍查询的完整语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    字段列表</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    表名列表 </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    分组字段</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    分组后条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    排序字段</span><br><span class="line">LIMIT</span><br><span class="line">    分页限定</span><br></pre></td></tr></table></figure><p>为了给大家演示查询的语句，我们需要先准备表及一些数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除stu表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> stu;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建stu表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu (</span><br><span class="line"> id <span class="type">int</span>, <span class="comment">-- 编号</span></span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">20</span>), <span class="comment">-- 姓名</span></span><br><span class="line"> age <span class="type">int</span>, <span class="comment">-- 年龄</span></span><br><span class="line"> sex <span class="type">varchar</span>(<span class="number">5</span>), <span class="comment">-- 性别</span></span><br><span class="line"> address <span class="type">varchar</span>(<span class="number">100</span>), <span class="comment">-- 地址</span></span><br><span class="line"> math <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>), <span class="comment">-- 数学成绩</span></span><br><span class="line"> english <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>), <span class="comment">-- 英语成绩</span></span><br><span class="line"> hire_date <span class="type">date</span> <span class="comment">-- 入学时间</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu(id,NAME,age,sex,address,math,english,hire_date) </span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;马运&#x27;</span>,<span class="number">55</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;杭州&#x27;</span>,<span class="number">66</span>,<span class="number">78</span>,<span class="string">&#x27;1995-09-01&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;马花疼&#x27;</span>,<span class="number">45</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>,<span class="number">98</span>,<span class="number">87</span>,<span class="string">&#x27;1998-09-01&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;马斯克&#x27;</span>,<span class="number">55</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;香港&#x27;</span>,<span class="number">56</span>,<span class="number">77</span>,<span class="string">&#x27;1999-09-02&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="string">&#x27;柳白&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;湖南&#x27;</span>,<span class="number">76</span>,<span class="number">65</span>,<span class="string">&#x27;1997-09-05&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>,<span class="string">&#x27;柳青&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;湖南&#x27;</span>,<span class="number">86</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;1998-09-01&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>,<span class="string">&#x27;刘德花&#x27;</span>,<span class="number">57</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;香港&#x27;</span>,<span class="number">99</span>,<span class="number">99</span>,<span class="string">&#x27;1998-09-01&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>,<span class="string">&#x27;张学右&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;香港&#x27;</span>,<span class="number">99</span>,<span class="number">99</span>,<span class="string">&#x27;1998-09-01&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>,<span class="string">&#x27;德玛西亚&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;南京&#x27;</span>,<span class="number">56</span>,<span class="number">65</span>,<span class="string">&#x27;1994-09-02&#x27;</span>);</span><br></pre></td></tr></table></figure><p>接下来咱们从最基本的查询语句开始学起。</p><h3 id="8-1-基础查询"><a href="#8-1-基础查询" class="headerlink" title="8.1  基础查询"></a>8.1  基础查询</h3><h4 id="8-1-1-语法"><a href="#8-1-1-语法" class="headerlink" title="8.1.1  语法"></a>8.1.1  语法</h4><ul><li><strong>查询多个字段</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名; <span class="comment">-- 查询所有数据</span></span><br></pre></td></tr></table></figure><ul><li><strong>去除重复记录</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><ul><li><strong>起别名</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AS</span>: <span class="keyword">AS</span> 也可以省略</span><br></pre></td></tr></table></figure><h4 id="8-1-2-练习"><a href="#8-1-2-练习" class="headerlink" title="8.1.2  练习"></a>8.1.2  练习</h4><ul><li><p>查询name、age两列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询所有列的数据，列名的列表可以使用*替代</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><p>上面语句中的*不建议大家使用，因为在这写*不方便我们阅读sql语句。我们写字段列表的话，可以添加注释对每一个字段进行说明</p><p>而在上课期间为了简约课程的时间，老师很多地方都会写*。</p></li><li><p>查询地址信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> address <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><p>执行上面语句结果如下：</p><p>从上面的结果我们可以看到有重复的数据，我们也可以使用 <code>distinct</code> 关键字去重重复数据。</p></li><li><p>去除重复记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> address <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询姓名、数学成绩、英语成绩。并通过as给math和english起别名（as关键字可以省略）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,math <span class="keyword">as</span> 数学成绩,english <span class="keyword">as</span> 英文成绩 <span class="keyword">from</span> stu;</span><br><span class="line"><span class="keyword">select</span> name,math 数学成绩,english 英文成绩 <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-2-条件查询"><a href="#8-2-条件查询" class="headerlink" title="8.2  条件查询"></a>8.2  条件查询</h3><h4 id="8-2-1-语法"><a href="#8-2-1-语法" class="headerlink" title="8.2.1  语法"></a>8.2.1  语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表;</span><br></pre></td></tr></table></figure><ul><li><strong>条件</strong></li></ul><p>条件列表可以使用以下运算符</p><h4 id="8-2-2-条件查询练习"><a href="#8-2-2-条件查询练习" class="headerlink" title="8.2.2  条件查询练习"></a>8.2.2  条件查询练习</h4><ul><li><p>查询年龄大于20岁的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄大于等于20岁的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄大于等于20岁 并且 年龄 小于等于 30岁 的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="operator">&amp;&amp;</span>  age <span class="operator">&lt;=</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">and</span>  age <span class="operator">&lt;=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上面语句中 &amp;&amp;  和  and  都表示并且的意思。建议使用 and 。</p><p>也可以使用  between … and 来实现上面需求</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询入学日期在’1998-09-01’ 到 ‘1999-09-01’  之间的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> hire_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;1998-09-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;1999-09-01&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄等于18岁的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄不等于18岁的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">!=</span> <span class="number">18</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&lt;&gt;</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄等于18岁 或者 年龄等于20岁 或者 年龄等于22岁的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">20</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="keyword">in</span> (<span class="number">18</span>,<span class="number">20</span> ,<span class="number">22</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询英语成绩为 null的学员信息</p><p>null值的比较不能使用 =  或者 != 。需要使用 is  或者 is not</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> english <span class="operator">=</span> <span class="keyword">null</span>; <span class="comment">-- 这个语句是不行的</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> english <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> english <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-2-3-模糊查询练习"><a href="#8-2-3-模糊查询练习" class="headerlink" title="8.2.3  模糊查询练习"></a>8.2.3  模糊查询练习</h4><blockquote><p>模糊查询使用like关键字，可以使用通配符进行占位:</p><p>（1）_ : 代表单个任意字符</p><p>（2）% : 代表任意个数字符</p></blockquote><ul><li><p>查询姓’马’的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;马%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询第二个字是’花’的学员信息  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;_花%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询名字中包含 ‘德’ 的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%德%&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-3-排序查询"><a href="#8-3-排序查询" class="headerlink" title="8.3  排序查询"></a>8.3  排序查询</h3><h4 id="8-3-1-语法"><a href="#8-3-1-语法" class="headerlink" title="8.3.1  语法"></a>8.3.1  语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序字段名<span class="number">1</span> [排序方式<span class="number">1</span>],排序字段名<span class="number">2</span> [排序方式<span class="number">2</span>] …;</span><br></pre></td></tr></table></figure><p>上述语句中的排序方式有两种，分别是：</p><ul><li>ASC ： 升序排列 <strong>（默认值）</strong></li><li>DESC ： 降序排列</li></ul><blockquote><p>注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序</p></blockquote><h4 id="8-3-2-练习"><a href="#8-3-2-练习" class="headerlink" title="8.3.2  练习"></a>8.3.2  练习</h4><ul><li><p>查询学生信息，按照年龄升序排列 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">order</span> <span class="keyword">by</span> age ;</span><br></pre></td></tr></table></figure></li><li><p>查询学生信息，按照数学成绩降序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">order</span> <span class="keyword">by</span> math <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure></li><li><p>查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">order</span> <span class="keyword">by</span> math <span class="keyword">desc</span> , english <span class="keyword">asc</span> ;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-4-聚合函数"><a href="#8-4-聚合函数" class="headerlink" title="8.4  聚合函数"></a>8.4  聚合函数</h3><h4 id="8-4-1-概念"><a href="#8-4-1-概念" class="headerlink" title="8.4.1  概念"></a>8.4.1  概念</h4><p> ==将一列数据作为一个整体，进行纵向计算。==</p><p>如何理解呢？假设有如下表</p><p>现有一需求让我们求表中所有数据的数学成绩的总和。这就是对math字段进行纵向求和。</p><h4 id="8-4-2-聚合函数分类"><a href="#8-4-2-聚合函数分类" class="headerlink" title="8.4.2  聚合函数分类"></a>8.4.2  聚合函数分类</h4><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>count(列名)</td><td>统计数量（一般选用不为null的列）</td></tr><tr><td>max(列名)</td><td>最大值</td></tr><tr><td>min(列名)</td><td>最小值</td></tr><tr><td>sum(列名)</td><td>求和</td></tr><tr><td>avg(列名)</td><td>平均值</td></tr></tbody></table><h4 id="8-4-3-聚合函数语法"><a href="#8-4-3-聚合函数语法" class="headerlink" title="8.4.3  聚合函数语法"></a>8.4.3  聚合函数语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数名(列名) <span class="keyword">FROM</span> 表;</span><br></pre></td></tr></table></figure><blockquote><p>注意：null 值不参与所有聚合函数运算</p></blockquote><h4 id="8-4-4-练习"><a href="#8-4-4-练习" class="headerlink" title="8.4.4  练习"></a>8.4.4  练习</h4><ul><li><p>统计班级一共有多少个学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> stu;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(english) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><p>上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以在count(*) 来实现。* 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(*)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的最高分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的最低分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的总分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的平均分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询英语成绩的最低分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(english) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-5-分组查询"><a href="#8-5-分组查询" class="headerlink" title="8.5  分组查询"></a>8.5  分组查询</h3><h4 id="8-5-1-语法"><a href="#8-5-1-语法" class="headerlink" title="8.5.1  语法"></a>8.5.1  语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 分组前条件限定] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后条件过滤];</span><br></pre></td></tr></table></figure><blockquote><p>注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</p></blockquote><h4 id="8-5-2-练习"><a href="#8-5-2-练习" class="headerlink" title="8.5.2  练习"></a>8.5.2  练习</h4><ul><li><p>查询男同学和女同学各自的数学平均分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="built_in">avg</span>(math) <span class="keyword">from</span> stu <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure><blockquote><p>注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, sex, <span class="built_in">avg</span>(math) <span class="keyword">from</span> stu <span class="keyword">group</span> <span class="keyword">by</span> sex;  <span class="comment">-- 这里查询name字段就没有任何意义</span></span><br></pre></td></tr></table></figure></li><li><p>查询男同学和女同学各自的数学平均分，以及各自人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="built_in">avg</span>(math),<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure></li><li><p>查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="built_in">avg</span>(math),<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu <span class="keyword">where</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure></li><li><p>查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组，分组之后人数大于2个的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="built_in">avg</span>(math),<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu <span class="keyword">where</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">group</span> <span class="keyword">by</span> sex <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)  <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>where 和 having 区别：</strong></p><ul><li><p>执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。</p></li><li><p>可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。</p></li></ul><h3 id="8-6-分页查询"><a href="#8-6-分页查询" class="headerlink" title="8.6  分页查询"></a>8.6  分页查询</h3><p>如下图所示，大家在很多网站都见过类似的效果，如京东、百度、淘宝等。分页查询是将数据一页一页的展示给用户看，用户也可以通过点击查看下一页的数据。</p><p>接下来我们先说分页查询的语法。</p><h4 id="8-6-1-语法"><a href="#8-6-1-语法" class="headerlink" title="8.6.1  语法"></a>8.6.1  语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT  起始索引 , 查询条目数;</span><br></pre></td></tr></table></figure><blockquote><p>注意： 上述语句中的起始索引是从0开始</p></blockquote><h4 id="8-6-2-练习"><a href="#8-6-2-练习" class="headerlink" title="8.6.2  练习"></a>8.6.2  练习</h4><ul><li><p>从0开始查询，查询3条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">0</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>每页显示3条数据，查询第1页数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">0</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>每页显示3条数据，查询第2页数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">3</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>每页显示3条数据，查询第3页数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">6</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><p>从上面的练习推导出起始索引计算公式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起始索引 <span class="operator">=</span> (当前页码 <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> 每页显示的条数</span><br></pre></td></tr></table></figure><h2 id="mysql高级"><a href="#mysql高级" class="headerlink" title="mysql高级"></a>mysql高级</h2><p><strong>今日目标</strong></p><blockquote><ul><li><p>掌握约束的使用</p></li><li><p>掌握表关系及建表原则</p></li><li><p>重点掌握多表查询操作</p></li><li><p>掌握事务操作</p></li></ul></blockquote><h2 id="1，约束"><a href="#1，约束" class="headerlink" title="1，约束"></a>1，约束</h2><p>上面表中可以看到表中数据存在一些问题：</p><ul><li><p>id 列一般是用标示数据的唯一性的，而上述表中的id为1的有三条数据，并且 <code>马花疼</code> 没有id进行标示</p></li><li><p><code>柳白</code> 这条数据的age列的数据是3000，而人也不可能活到3000岁</p></li><li><p><code>马运</code>  这条数据的math数学成绩是-5，而数学学得再不好也不可能出现负分</p></li><li><p><code>柳青</code> 这条数据的english列（英文成绩）值为null，而成绩即使没考也得是0分</p></li></ul><p>针对上述数据问题，我们就可以从数据库层面在添加数据的时候进行限制，这个就是约束。</p><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1  概念"></a>1.1  概念</h3><ul><li><p>约束是作用于表中列上的规则，用于限制加入表的数据</p><p>例如：我们可以给id列加约束，让其值不能重复，不能为null值。</p></li><li><p>约束的存在保证了数据库中数据的正确性、有效性和完整性</p><p>添加约束可以在添加数据的时候就限制不正确的数据，年龄是3000，数学成绩是-5分这样无效的数据，继而保障数据的完整性。</p></li></ul><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2  分类"></a>1.2  分类</h3><ul><li><p><strong>非空约束： 关键字是 NOT NULL</strong></p><p>保证列中所有的数据不能有null值。</p><p>例如：id列在添加 <code>马花疼</code> 这条数据时就不能添加成功。</p></li><li><p><strong>唯一约束：关键字是  UNIQUE</strong></p><p>保证列中所有数据各不相同。</p><p>例如：id列中三条数据的值都是1，这样的数据在添加时是绝对不允许的。</p></li><li><p><strong>主键约束： 关键字是  PRIMARY KEY</strong></p><p>主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给没张表添加一个主键列用来唯一标识数据。</p><p>例如：上图表中id就可以作为主键，来标识每条数据。那么这样就要求数据中id的值不能重复，不能为null值。</p></li><li><p><strong>检查约束： 关键字是  CHECK</strong> </p><p>保证列中的值满足某一条件。</p><p>例如：我们可以给age列添加一个范围，最低年龄可以设置为1，最大年龄就可以设置为300，这样的数据才更合理些。</p><blockquote><p>注意：MySQL不支持检查约束。</p><p>这样是不是就没办法保证年龄在指定的范围内了？从数据库层面不能保证，以后可以在java代码中进行限制，一样也可以实现要求。</p></blockquote></li><li><p><strong>默认约束： 关键字是   DEFAULT</strong></p><p>保存数据时，未指定值则采用默认值。</p><p>例如：我们在给english列添加该约束，指定默认值是0，这样在添加数据时没有指定具体值时就会采用默认给定的0。</p></li><li><p><strong>外键约束： 关键字是  FOREIGN KEY</strong></p><p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</p><p>外键约束现在可能还不太好理解，后面我们会重点进行讲解。</p></li></ul><h3 id="1-3-非空约束"><a href="#1-3-非空约束" class="headerlink" title="1.3  非空约束"></a>1.3  非空约束</h3><ul><li><p>概念</p><p>非空约束用于保证列中所有数据不能有NULL值</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加非空约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   …</span><br><span class="line">); </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建完表后添加非空约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 数据类型;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-4-唯一约束"><a href="#1-4-唯一约束" class="headerlink" title="1.4  唯一约束"></a>1.4  唯一约束</h3><ul><li><p>概念</p><p>唯一约束用于保证列中所有数据各不相同</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加唯一约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型 <span class="keyword">UNIQUE</span> [AUTO_INCREMENT],</span><br><span class="line">   <span class="comment">-- AUTO_INCREMENT: 当不指定值时自动增长</span></span><br><span class="line">   …</span><br><span class="line">); </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型,</span><br><span class="line">   …</span><br><span class="line">   [<span class="keyword">CONSTRAINT</span>] [约束名称] <span class="keyword">UNIQUE</span>(列名)</span><br><span class="line">); </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建完表后添加唯一约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 数据类型 <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> INDEX 字段名;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-5-主键约束"><a href="#1-5-主键约束" class="headerlink" title="1.5  主键约束"></a>1.5  主键约束</h3><ul><li><p>概念</p><p>主键是一行数据的唯一标识，要求非空且唯一</p><p>一张表只能有一个主键</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加主键约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型 <span class="keyword">PRIMARY</span> KEY [AUTO_INCREMENT],</span><br><span class="line">   …</span><br><span class="line">); </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型,</span><br><span class="line">   [<span class="keyword">CONSTRAINT</span>] [约束名称] <span class="keyword">PRIMARY</span> KEY(列名)</span><br><span class="line">); </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建完表后添加主键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(字段名);</span><br></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-6-默认约束"><a href="#1-6-默认约束" class="headerlink" title="1.6  默认约束"></a>1.6  默认约束</h3><ul><li><p>概念</p><p>保存数据时，未指定值则采用默认值</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加默认约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型 <span class="keyword">DEFAULT</span> 默认值,</span><br><span class="line">   …</span><br><span class="line">); </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建完表后添加默认约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ALTER</span> 列名 <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> 默认值;</span><br></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ALTER</span> 列名 <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-7-约束练习"><a href="#1-7-约束练习" class="headerlink" title="1.7  约束练习"></a>1.7  约束练习</h3><p><strong>根据需求，为表添加合适的约束</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">id <span class="type">INT</span>,  <span class="comment">-- 员工id，主键且自增长</span></span><br><span class="line">    ename <span class="type">VARCHAR</span>(<span class="number">50</span>), <span class="comment">-- 员工姓名，非空且唯一</span></span><br><span class="line">    joindate <span class="type">DATE</span>,  <span class="comment">-- 入职日期，非空</span></span><br><span class="line">    salary <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>),  <span class="comment">-- 工资，非空</span></span><br><span class="line">    bonus <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>)  <span class="comment">-- 奖金，如果没有将近默认为0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面一定给出了具体的要求，我们可以根据要求创建这张表，并为每一列添加对应的约束。建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 员工id，主键且自增长</span></span><br><span class="line">  ename <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>, <span class="comment">-- 员工姓名，非空并且唯一</span></span><br><span class="line">  joindate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> , <span class="comment">-- 入职日期，非空</span></span><br><span class="line">  salary <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> , <span class="comment">-- 工资，非空</span></span><br><span class="line">  bonus <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="comment">-- 奖金，如果没有奖金默认为0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过上面语句可以创建带有约束的 <code>emp</code> 表，约束能不能发挥作用呢。接下来我们一一进行验证，先添加一条没有问题的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>验证主键约束，非空且唯一</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p>从上面的结果可以看到，字段 <code>id</code> 不能为null。那我们重新添加一条数据，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p>从上面结果可以看到，1这个值重复了。所以主键约束是用来限制数据非空且唯一的。那我们再添加一条符合要求的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><ul><li><strong>验证非空约束</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">3</span>,<span class="keyword">null</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p>从上面结果可以看到，<code>ename</code> 字段的非空约束生效了。</p><ul><li><strong>验证唯一约束</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p>从上面结果可以看到，<code>ename</code> 字段的唯一约束生效了。</p><ul><li><strong>验证默认约束</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>);</span><br></pre></td></tr></table></figure><p>执行完上面语句后查询表中数据，如下图可以看到王五这条数据的bonus列就有了默认值0。</p><p>==注意：默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值。==</p><p>如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>执行完上面语句后查询表中数据，如下图可以看到赵六这条数据的bonus列的值是null。</p><ul><li><strong>验证自动增长： auto_increment  当列是数字类型 并且唯一约束</strong></li></ul><p>重新创建 <code>emp</code> 表，并给id列添加自动增长</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY auto_increment, <span class="comment">-- 员工id，主键且自增长</span></span><br><span class="line">  ename <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>, <span class="comment">-- 员工姓名，非空并且唯一</span></span><br><span class="line">  joindate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> , <span class="comment">-- 入职日期，非空</span></span><br><span class="line">  salary <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> , <span class="comment">-- 工资，非空</span></span><br><span class="line">  bonus <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="comment">-- 奖金，如果没有奖金默认为0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接下来给emp添加数据，分别验证不给id列添加值以及给id列添加null值，id列的值会不会自动增长：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;赵六2&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;赵六3&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="1-8-外键约束"><a href="#1-8-外键约束" class="headerlink" title="1.8  外键约束"></a>1.8  外键约束</h3><h4 id="1-8-1-概述"><a href="#1-8-1-概述" class="headerlink" title="1.8.1  概述"></a>1.8.1  概述</h4><p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</p><p>如何理解上面的概念呢？如下图有两张表，员工表和部门表：</p><p>员工表中的dep_id字段是部门表的id字段关联，也就是说1号学生张三属于1号部门研发部的员工。现在我要删除1号部门，就会出现错误的数据（员工表中属于1号部门的数据）。而我们上面说的两张表的关系只是我们认为它们有关系，此时需要通过外键让这两张表产生数据库层面的关系，这样你要删除部门表中的1号部门的数据将无法删除。</p><h4 id="1-8-2-语法"><a href="#1-8-2-语法" class="headerlink" title="1.8.2  语法"></a>1.8.2  语法</h4><ul><li>添加外键约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加外键约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型,</span><br><span class="line">   …</span><br><span class="line">   [<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY(外键列名) <span class="keyword">REFERENCES</span> 主表(主表列名) </span><br><span class="line">); </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建完表后添加外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称);</span><br></pre></td></tr></table></figure><ul><li>删除外键约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称;</span><br></pre></td></tr></table></figure><h4 id="1-8-3-练习"><a href="#1-8-3-练习" class="headerlink" title="1.8.3  练习"></a>1.8.3  练习</h4><p>根据上述语法创建员工表和部门表，并添加上外键约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> emp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> dept;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部门表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 员工表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">dep_id <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键 dep_id,关联 dept 表的id主键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_emp_dept <span class="keyword">FOREIGN</span> KEY(dep_id) <span class="keyword">REFERENCES</span> dept(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加 2 个部门</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept(dep_name,addr) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;研发部&#x27;</span>,<span class="string">&#x27;广州&#x27;</span>),(<span class="string">&#x27;销售部&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加员工,dep_id 表示员工所在的部门</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (NAME, age, dep_id) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;李四&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;王五&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;赵六&#x27;</span>, <span class="number">20</span>, <span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;孙七&#x27;</span>, <span class="number">22</span>, <span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;周八&#x27;</span>, <span class="number">18</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>此时删除 <code>研发部</code> 这条数据，会发现无法删除。</p><p>删除外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> <span class="keyword">FOREIGN</span> key fk_emp_dept;</span><br></pre></td></tr></table></figure><p>重新添加外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">CONSTRAINT</span> fk_emp_dept <span class="keyword">FOREIGN</span> key(dep_id) <span class="keyword">REFERENCES</span> dept(id);</span><br></pre></td></tr></table></figure><h2 id="2，数据库设计"><a href="#2，数据库设计" class="headerlink" title="2，数据库设计"></a>2，数据库设计</h2><h3 id="2-1-数据库设计简介"><a href="#2-1-数据库设计简介" class="headerlink" title="2.1  数据库设计简介"></a>2.1  数据库设计简介</h3><ul><li><p>软件的研发步骤</p></li><li><p>数据库设计概念</p><ul><li>数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型。</li><li>建立数据库中的==表结构==以及==表与表之间的关联关系==的过程。</li><li>有哪些表？表里有哪些字段？表和表之间有什么关系？</li></ul></li><li><p>数据库设计的步骤</p><ul><li><p>需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么）</p></li><li><p>逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）</p><p>如下图就是ER(Entity/Relation)图：</p></li><li><p>物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）</p></li><li><p>维护设计（1.对新的需求进行建表；2.表优化）</p></li></ul></li><li><p>表关系</p><ul><li><p>一对一</p><ul><li>如：用户 和 用户详情</li><li>一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</li></ul><p>上图左边是用户的详细信息，而我们真正在展示用户信息时最长用的则是上图右边红框所示，所以我们会将详细信息查分成两周那个表。</p></li><li><p>一对多</p><ul><li><p>如：部门 和 员工</p></li><li><p>一个部门对应多个员工，一个员工对应一个部门。如下图：</p></li></ul></li><li><p>多对多</p><ul><li><p>如：商品 和 订单</p></li><li><p>一个商品对应多个订单，一个订单包含多个商品。如下图：</p></li></ul></li></ul></li></ul><h3 id="2-2-表关系-一对多"><a href="#2-2-表关系-一对多" class="headerlink" title="2.2  表关系(一对多)"></a>2.2  表关系(一对多)</h3><ul><li><p>一对多</p><ul><li>如：部门 和 员工</li><li>一个部门对应多个员工，一个员工对应一个部门。</li></ul></li><li><p>实现方式</p><p>==在多的一方建立外键，指向一的一方的主键==</p></li><li><p>案例</p><p>我们还是以 <code>员工表</code> 和 <code>部门表</code> 举例:</p><p>经过分析发现，员工表属于多的一方，而部门表属于一的一方，此时我们会在员工表中添加一列（dep_id），指向于部门表的主键（id）：</p><p>建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_emp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_dept;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部门表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_dept(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 员工表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_emp(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">dep_id <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键 dep_id,关联 dept 表的id主键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_emp_dept <span class="keyword">FOREIGN</span> KEY(dep_id) <span class="keyword">REFERENCES</span> tb_dept(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>查看表结构模型图：</p></li></ul><h3 id="2-3-表关系-多对多"><a href="#2-3-表关系-多对多" class="headerlink" title="2.3  表关系(多对多)"></a>2.3  表关系(多对多)</h3><ul><li><p>多对多</p><ul><li>如：商品 和 订单</li><li>一个商品对应多个订单，一个订单包含多个商品</li></ul></li><li><p>实现方式</p><p>==建立第三张中间表，中间表至少包含两个外键，分别关联两方主键==</p></li><li><p>案例</p><p>我们以 <code>订单表</code> 和 <code>商品表</code> 举例：</p><p>经过分析发现，订单表和商品表都属于多的一方，此时需要创建一个中间表，在中间表中添加订单表的外键和商品表的外键指向两张表的主键：</p><p>建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_order_goods;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_order;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_goods;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_order(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">payment <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">payment_type TINYINT,</span><br><span class="line">status TINYINT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 商品表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_goods(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">title <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">price <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单商品中间表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_order_goods(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">order_id <span class="type">int</span>,</span><br><span class="line">goods_id <span class="type">int</span>,</span><br><span class="line">count <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建完表后，添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_order_goods <span class="keyword">add</span> <span class="keyword">CONSTRAINT</span> fk_order_id <span class="keyword">FOREIGN</span> key(order_id) <span class="keyword">REFERENCES</span> tb_order(id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_order_goods <span class="keyword">add</span> <span class="keyword">CONSTRAINT</span> fk_goods_id <span class="keyword">FOREIGN</span> key(goods_id) <span class="keyword">REFERENCES</span> tb_goods(id);</span><br></pre></td></tr></table></figure><p>查看表结构模型图：</p></li></ul><h3 id="2-4-表关系-一对一"><a href="#2-4-表关系-一对一" class="headerlink" title="2.4  表关系(一对一)"></a>2.4  表关系(一对一)</h3><ul><li><p>一对一</p><ul><li>如：用户 和 用户详情</li><li>一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</li></ul></li><li><p>实现方式</p><p>==在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)==</p></li><li><p>案例</p><p>我们以 <code>用户表</code> 举例：</p><p>而在真正使用过程中发现 id、photo、nickname、age、gender 字段比较常用，此时就可以将这张表查分成两张表。</p></li></ul><p>​    </p><p>​    建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user_desc (</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">edu <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">income <span class="type">int</span>,</span><br><span class="line">status <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">des <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user (</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">photo <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">nickname <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">desc_id <span class="type">int</span> <span class="keyword">unique</span>,</span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_user_desc <span class="keyword">FOREIGN</span> KEY(desc_id) <span class="keyword">REFERENCES</span> tb_user_desc(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="3，多表查询"><a href="#3，多表查询" class="headerlink" title="3，多表查询"></a>3，多表查询</h2><p>多表查询顾名思义就是从多张表中一次性的查询出我们想要的数据。我们通过具体的sql给他们演示，先准备环境</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> emp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> dept;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建部门表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">        did <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">        dname <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"># 创建员工表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">        id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">        NAME <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">        gender <span class="type">CHAR</span>(<span class="number">1</span>), <span class="comment">-- 性别</span></span><br><span class="line">        salary <span class="keyword">DOUBLE</span>, <span class="comment">-- 工资</span></span><br><span class="line">        join_date <span class="type">DATE</span>, <span class="comment">-- 入职日期</span></span><br><span class="line">        dep_id <span class="type">INT</span>,</span><br><span class="line">        <span class="keyword">FOREIGN</span> KEY (dep_id) <span class="keyword">REFERENCES</span> dept(did) <span class="comment">-- 外键，关联部门表(部门表的主键)</span></span><br><span class="line">    );</span><br><span class="line"><span class="comment">-- 添加部门数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept (dNAME) <span class="keyword">VALUES</span> (<span class="string">&#x27;研发部&#x27;</span>),(<span class="string">&#x27;市场部&#x27;</span>),(<span class="string">&#x27;财务部&#x27;</span>),(<span class="string">&#x27;销售部&#x27;</span>);</span><br><span class="line"><span class="comment">-- 添加员工数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dep_id) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">7200</span>,<span class="string">&#x27;2013-02-24&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;猪八戒&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">3600</span>,<span class="string">&#x27;2010-12-02&#x27;</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;唐僧&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">9000</span>,<span class="string">&#x27;2008-08-08&#x27;</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;白骨精&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">5000</span>,<span class="string">&#x27;2015-10-07&#x27;</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="string">&#x27;蜘蛛精&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">4500</span>,<span class="string">&#x27;2011-03-14&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;小白龙&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">2500</span>,<span class="string">&#x27;2011-02-14&#x27;</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>执行下面的多表查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp , dept;  <span class="comment">-- 从emp和dept表中查询所有的字段数据</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><p>从上面的结果我们看到有一些无效的数据，如 <code>孙悟空</code> 这个员工属于1号部门，但也同时关联的2、3、4号部门。所以我们要通过限制员工表中的 <code>dep_id</code> 字段的值和部门表 <code>did</code> 字段的值相等来消除这些无效的数据，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp , dept <span class="keyword">where</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p>执行后结果如下：</p><p>上面语句就是连接查询，那么多表查询都有哪些呢？</p><ul><li><p>连接查询 </p><ul><li>内连接查询 ：相当于查询AB交集数据</li><li>外连接查询<ul><li>左外连接查询 ：相当于查询A表所有数据和交集部门数据</li><li>右外连接查询 ： 相当于查询B表所有数据和交集部分数据</li></ul></li></ul></li><li><p>子查询</p></li></ul><h3 id="3-1-内连接查询"><a href="#3-1-内连接查询" class="headerlink" title="3.1  内连接查询"></a>3.1  内连接查询</h3><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2</span>… <span class="keyword">WHERE</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure><blockquote><p>内连接相当于查询 A B 交集数据</p></blockquote><ul><li><p>案例</p><ul><li><p>隐式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">dept</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p>执行上述语句结果如下：</p></li><li><p>查询 emp的 name， gender，dept表的dname</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp. NAME,</span><br><span class="line">emp.gender,</span><br><span class="line">dept.dname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">dept</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p>执行语句结果如下：</p><p>上面语句中使用表名指定字段所属有点麻烦，sql也支持给表指别名，上述语句可以改进为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">t1. NAME,</span><br><span class="line">t1.gender,</span><br><span class="line">t2.dname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp t1,</span><br><span class="line">dept t2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t1.dep_id <span class="operator">=</span> t2.did;</span><br></pre></td></tr></table></figure></li><li><p>显式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br><span class="line"><span class="comment">-- 上面语句中的inner可以省略，可以书写为如下语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp  <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p></li></ul></li></ul><h3 id="3-2-外连接查询"><a href="#3-2-外连接查询" class="headerlink" title="3.2  外连接查询"></a>3.2  外连接查询</h3><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure><blockquote><p>左外连接：相当于查询A表所有数据和交集部分数据</p><p>右外连接：相当于查询B表所有数据和交集部分数据</p></blockquote></li><li><p>案例</p><ul><li><p>查询emp表所有数据和对应的部门信息（左外连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p>执行语句结果如下：</p><p>结果显示查询到了左表（emp）中所有的数据及两张表能关联的数据。</p></li><li><p>查询dept表所有数据和对应的员工信息（右外连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">right</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p>执行语句结果如下：</p><p>结果显示查询到了右表（dept）中所有的数据及两张表能关联的数据。</p><p>要查询出部门表中所有的数据，也可以通过左外连接实现，只需要将两个表的位置进行互换：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-3-子查询"><a href="#3-3-子查询" class="headerlink" title="3.3  子查询"></a>3.3  子查询</h3><ul><li><p>概念</p><p>==查询中嵌套查询，称嵌套查询为子查询。==</p><p>什么是查询中嵌套查询呢？我们通过一个例子来看：</p><p><strong>需求：查询工资高于猪八戒的员工信息。</strong></p><p>来实现这个需求，我们就可以通过二步实现，第一步：先查询出来 猪八戒的工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;猪八戒&#x27;</span></span><br></pre></td></tr></table></figure><p> 第二步：查询工资高于猪八戒的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="number">3600</span>;</span><br></pre></td></tr></table></figure><p>第二步中的3600可以通过第一步的sql查询出来，所以将3600用第一步的sql语句进行替换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;猪八戒&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这就是查询语句中嵌套查询语句。</p></li><li><p>子查询根据查询结果不同，作用不同</p><ul><li>子查询语句结果是单行单列，子查询语句作为条件值，使用 =  !=  &gt;  &lt;  等进行条件判断</li><li>子查询语句结果是多行单列，子查询语句作为条件值，使用 in 等关键字进行条件判断</li><li>子查询语句结果是多行多列，子查询语句作为虚拟表</li></ul></li><li><p>案例</p><ul><li><p>查询 ‘财务部’ 和 ‘市场部’ 所有的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询 &#x27;财务部&#x27; 或者 &#x27;市场部&#x27; 所有的员工的部门did</span></span><br><span class="line"><span class="keyword">select</span> did <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">or</span> dname <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dep_id <span class="keyword">in</span> (<span class="keyword">select</span> did <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">or</span> dname <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询入职日期是 ‘2011-11-11’ 之后的员工信息和部门信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询入职日期是 &#x27;2011-11-11&#x27; 之后的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> join_date <span class="operator">&gt;</span> <span class="string">&#x27;2011-11-11&#x27;</span> ;</span><br><span class="line"><span class="comment">-- 将上面语句的结果作为虚拟表和dept表进行内连接查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> join_date <span class="operator">&gt;</span> <span class="string">&#x27;2011-11-11&#x27;</span> ) t1, dept <span class="keyword">where</span> t1.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-4-案例"><a href="#3-4-案例" class="headerlink" title="3.4  案例"></a>3.4  案例</h3><ul><li>环境准备：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> emp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> dept;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> job;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> salarygrade;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部门表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept (</span><br><span class="line">  did <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 部门id</span></span><br><span class="line">  dname <span class="type">VARCHAR</span>(<span class="number">50</span>), <span class="comment">-- 部门名称</span></span><br><span class="line">  loc <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="comment">-- 部门所在地</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 职务表，职务名称，职务描述</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> job (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  jname <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  description <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 员工id</span></span><br><span class="line">  ename <span class="type">VARCHAR</span>(<span class="number">50</span>), <span class="comment">-- 员工姓名</span></span><br><span class="line">  job_id <span class="type">INT</span>, <span class="comment">-- 职务id</span></span><br><span class="line">  mgr <span class="type">INT</span> , <span class="comment">-- 上级领导</span></span><br><span class="line">  joindate <span class="type">DATE</span>, <span class="comment">-- 入职日期</span></span><br><span class="line">  salary <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>), <span class="comment">-- 工资</span></span><br><span class="line">  bonus <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>), <span class="comment">-- 奖金</span></span><br><span class="line">  dept_id <span class="type">INT</span>, <span class="comment">-- 所在部门编号</span></span><br><span class="line">  <span class="keyword">CONSTRAINT</span> emp_jobid_ref_job_id_fk <span class="keyword">FOREIGN</span> KEY (job_id) <span class="keyword">REFERENCES</span> job (id),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> emp_deptid_ref_dept_id_fk <span class="keyword">FOREIGN</span> KEY (dept_id) <span class="keyword">REFERENCES</span> dept (id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 工资等级表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salarygrade (</span><br><span class="line">  grade <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,   <span class="comment">-- 级别</span></span><br><span class="line">  losalary <span class="type">INT</span>,  <span class="comment">-- 最低工资</span></span><br><span class="line">  hisalary <span class="type">INT</span> <span class="comment">-- 最高工资</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加4个部门</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept(did,dname,loc) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">10</span>,<span class="string">&#x27;教研部&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>),</span><br><span class="line">(<span class="number">20</span>,<span class="string">&#x27;学工部&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>),</span><br><span class="line">(<span class="number">30</span>,<span class="string">&#x27;销售部&#x27;</span>,<span class="string">&#x27;广州&#x27;</span>),</span><br><span class="line">(<span class="number">40</span>,<span class="string">&#x27;财务部&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加4个职务</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> job (id, jname, description) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;董事长&#x27;</span>, <span class="string">&#x27;管理整个公司，接单&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;经理&#x27;</span>, <span class="string">&#x27;管理部门员工&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;销售员&#x27;</span>, <span class="string">&#x27;向客人推销产品&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;文员&#x27;</span>, <span class="string">&#x27;使用办公软件&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加员工</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1001</span>,<span class="string">&#x27;孙悟空&#x27;</span>,<span class="number">4</span>,<span class="number">1004</span>,<span class="string">&#x27;2000-12-17&#x27;</span>,<span class="string">&#x27;8000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">1002</span>,<span class="string">&#x27;卢俊义&#x27;</span>,<span class="number">3</span>,<span class="number">1006</span>,<span class="string">&#x27;2001-02-20&#x27;</span>,<span class="string">&#x27;16000.00&#x27;</span>,<span class="string">&#x27;3000.00&#x27;</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1003</span>,<span class="string">&#x27;林冲&#x27;</span>,<span class="number">3</span>,<span class="number">1006</span>,<span class="string">&#x27;2001-02-22&#x27;</span>,<span class="string">&#x27;12500.00&#x27;</span>,<span class="string">&#x27;5000.00&#x27;</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1004</span>,<span class="string">&#x27;唐僧&#x27;</span>,<span class="number">2</span>,<span class="number">1009</span>,<span class="string">&#x27;2001-04-02&#x27;</span>,<span class="string">&#x27;29750.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">1005</span>,<span class="string">&#x27;李逵&#x27;</span>,<span class="number">4</span>,<span class="number">1006</span>,<span class="string">&#x27;2001-09-28&#x27;</span>,<span class="string">&#x27;12500.00&#x27;</span>,<span class="string">&#x27;14000.00&#x27;</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1006</span>,<span class="string">&#x27;宋江&#x27;</span>,<span class="number">2</span>,<span class="number">1009</span>,<span class="string">&#x27;2001-05-01&#x27;</span>,<span class="string">&#x27;28500.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1007</span>,<span class="string">&#x27;刘备&#x27;</span>,<span class="number">2</span>,<span class="number">1009</span>,<span class="string">&#x27;2001-09-01&#x27;</span>,<span class="string">&#x27;24500.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">10</span>),</span><br><span class="line">(<span class="number">1008</span>,<span class="string">&#x27;猪八戒&#x27;</span>,<span class="number">4</span>,<span class="number">1004</span>,<span class="string">&#x27;2007-04-19&#x27;</span>,<span class="string">&#x27;30000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">1009</span>,<span class="string">&#x27;罗贯中&#x27;</span>,<span class="number">1</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;2001-11-17&#x27;</span>,<span class="string">&#x27;50000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">10</span>),</span><br><span class="line">(<span class="number">1010</span>,<span class="string">&#x27;吴用&#x27;</span>,<span class="number">3</span>,<span class="number">1006</span>,<span class="string">&#x27;2001-09-08&#x27;</span>,<span class="string">&#x27;15000.00&#x27;</span>,<span class="string">&#x27;0.00&#x27;</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1011</span>,<span class="string">&#x27;沙僧&#x27;</span>,<span class="number">4</span>,<span class="number">1004</span>,<span class="string">&#x27;2007-05-23&#x27;</span>,<span class="string">&#x27;11000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">1012</span>,<span class="string">&#x27;李逵&#x27;</span>,<span class="number">4</span>,<span class="number">1006</span>,<span class="string">&#x27;2001-12-03&#x27;</span>,<span class="string">&#x27;9500.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1013</span>,<span class="string">&#x27;小白龙&#x27;</span>,<span class="number">4</span>,<span class="number">1004</span>,<span class="string">&#x27;2001-12-03&#x27;</span>,<span class="string">&#x27;30000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">1014</span>,<span class="string">&#x27;关羽&#x27;</span>,<span class="number">4</span>,<span class="number">1007</span>,<span class="string">&#x27;2002-01-23&#x27;</span>,<span class="string">&#x27;13000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加5个工资等级</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salarygrade(grade,losalary,hisalary) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>,<span class="number">7000</span>,<span class="number">12000</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="number">12010</span>,<span class="number">14000</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="number">14010</span>,<span class="number">20000</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="number">20010</span>,<span class="number">30000</span>),</span><br><span class="line">(<span class="number">5</span>,<span class="number">30010</span>,<span class="number">99990</span>);</span><br></pre></td></tr></table></figure><ul><li><p>需求</p><ol><li><p>查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span></span><br><span class="line"><span class="comment">2. 职务名称，职务描述 信息在 job 职务表中</span></span><br><span class="line"><span class="comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 方式一 ：隐式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.id,</span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">job.jname,</span><br><span class="line">job.description</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">job</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.job_id <span class="operator">=</span> job.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二 ：显式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.id,</span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">job.jname,</span><br><span class="line">job.description</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job <span class="keyword">ON</span> emp.job_id <span class="operator">=</span> job.id;</span><br></pre></td></tr></table></figure></li><li><p>查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span></span><br><span class="line"><span class="comment">2. 职务名称，职务描述 信息在 job 职务表中</span></span><br><span class="line"><span class="comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 部门名称，部门位置 来自于 部门表 dept</span></span><br><span class="line"><span class="comment">5. dept 和 emp 一对多关系 dept.id = emp.dept_id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式一 ：隐式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.id,</span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">job.jname,</span><br><span class="line">job.description,</span><br><span class="line">dept.dname,</span><br><span class="line">dept.loc</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">job,</span><br><span class="line">dept</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.job_id <span class="operator">=</span> job.id</span><br><span class="line"><span class="keyword">and</span> dept.id <span class="operator">=</span> emp.dept_id</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二 ：显式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.id,</span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">job.jname,</span><br><span class="line">job.description,</span><br><span class="line">dept.dname,</span><br><span class="line">dept.loc</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job <span class="keyword">ON</span> emp.job_id <span class="operator">=</span> job.id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> dept.id <span class="operator">=</span> emp.dept_id</span><br></pre></td></tr></table></figure></li><li><p>查询员工姓名，工资，工资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 员工姓名，工资 信息在emp 员工表中</span></span><br><span class="line"><span class="comment">2. 工资等级 信息在 salarygrade 工资等级表中</span></span><br><span class="line"><span class="comment">3. emp.salary &gt;= salarygrade.losalary  and emp.salary &lt;= salarygrade.hisalary</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">t2.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">salarygrade t2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.salary <span class="operator">&gt;=</span> t2.losalary</span><br><span class="line"><span class="keyword">AND</span> emp.salary <span class="operator">&lt;=</span> t2.hisalary</span><br></pre></td></tr></table></figure></li><li><p>查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span></span><br><span class="line"><span class="comment">2. 职务名称，职务描述 信息在 job 职务表中</span></span><br><span class="line"><span class="comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 部门名称，部门位置 来自于 部门表 dept</span></span><br><span class="line"><span class="comment">5. dept 和 emp 一对多关系 dept.id = emp.dept_id</span></span><br><span class="line"><span class="comment">6. 工资等级 信息在 salarygrade 工资等级表中</span></span><br><span class="line"><span class="comment">7. emp.salary &gt;= salarygrade.losalary  and emp.salary &lt;= salarygrade.hisalary</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.id,</span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">job.jname,</span><br><span class="line">job.description,</span><br><span class="line">dept.dname,</span><br><span class="line">dept.loc,</span><br><span class="line">t2.grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job <span class="keyword">ON</span> emp.job_id <span class="operator">=</span> job.id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> dept.id <span class="operator">=</span> emp.dept_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> salarygrade t2 <span class="keyword">ON</span> emp.salary <span class="keyword">BETWEEN</span> t2.losalary <span class="keyword">and</span> t2.hisalary;</span><br></pre></td></tr></table></figure></li><li><p>查询出部门编号、部门名称、部门位置、部门人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 部门编号、部门名称、部门位置 来自于部门 dept 表</span></span><br><span class="line"><span class="comment">2. 部门人数: 在emp表中 按照dept_id 进行分组，然后count(*)统计数量</span></span><br><span class="line"><span class="comment">3. 使用子查询，让部门表和分组后的表进行内连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 根据部门id分组查询每一个部门id和员工数</span></span><br><span class="line"><span class="keyword">select</span> dept_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> dept_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">dept.id,</span><br><span class="line">dept.dname,</span><br><span class="line">dept.loc,</span><br><span class="line">t1.count</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">dept,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">dept_id,</span><br><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) count</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">dept_id</span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">dept.id <span class="operator">=</span> t1.dept_id</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="4，事务"><a href="#4，事务" class="headerlink" title="4，事务"></a>4，事务</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1  概述"></a>4.1  概述</h3><blockquote><p>数据库的事务（Transaction）是一种机制、一个操作序列，包含了==一组数据库操作命令==。</p><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令==要么同时成功，要么同时失败==。</p><p>事务是一个不可分割的工作逻辑单元。</p></blockquote><p>这些概念不好理解，接下来举例说明，如下图有一张表</p><p>张三和李四账户中各有100块钱，现李四需要转换500块钱给张三，具体的转账操作为</p><ul><li>第一步：查询李四账户余额</li><li>第二步：从李四账户金额 -500</li><li>第三步：给张三账户金额 +500</li></ul><p>现在假设在转账过程中第二步完成后出现了异常第三步没有执行，就会造成李四账户金额少了500，而张三金额并没有多500；这样的系统是有问题的。如果解决呢？使用事务可以解决上述问题</p><p>从上图可以看到在转账前开启事务，如果出现了异常回滚事务，三步正常执行就提交事务，这样就可以完美解决问题。</p><h3 id="4-2-语法"><a href="#4-2-语法" class="headerlink" title="4.2  语法"></a>4.2  语法</h3><ul><li><p>开启事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">或者  </span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-代码验证"><a href="#4-3-代码验证" class="headerlink" title="4.3  代码验证"></a>4.3  代码验证</h3><ul><li><p>环境准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> account;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建账户表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(name,money) <span class="keyword">values</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="number">1000</span>),(<span class="string">&#x27;李四&#x27;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>不加事务演示问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 转账操作</span></span><br><span class="line"><span class="comment">-- 1. 查询李四账户金额是否大于500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 李四账户 -500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line">出现异常了...  <span class="comment">-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行</span></span><br><span class="line"><span class="comment">-- 3. 张三账户 +500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure><p>整体执行结果肯定会出问题，我们查询账户表中数据，发现李四账户少了500。</p></li><li><p>添加事务sql如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 转账操作</span></span><br><span class="line"><span class="comment">-- 1. 查询李四账户金额是否大于500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 李四账户 -500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line">出现异常了...  <span class="comment">-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行</span></span><br><span class="line"><span class="comment">-- 3. 张三账户 +500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>上面sql中的执行成功进选择执行提交事务，而出现问题则执行回滚事务的语句。以后我们肯定不可能这样操作，而是在java中进行操作，在java中可以抓取异常，没出现异常提交事务，出现异常回滚事务。</p></li></ul><h3 id="4-4-事务的四大特征"><a href="#4-4-事务的四大特征" class="headerlink" title="4.4  事务的四大特征"></a>4.4  事务的四大特征</h3><ul><li><p>原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</p></li><li><p>一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态</p></li><li><p>隔离性（Isolation） :多个事务之间，操作的可见性</p></li><li><p>持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p></li></ul><blockquote><p>==说明：==</p><p>mysql中事务是自动提交的。</p><p>也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务。</p><p>可以通过下面语句查询默认提交方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @<span class="meta">@autocommit</span>;</span><br></pre></td></tr></table></figure><p>查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2022/12/10/Maven/"/>
      <url>/2022/12/10/Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven学习笔记"><a href="#Maven学习笔记" class="headerlink" title="Maven学习笔记"></a>Maven学习笔记</h1><h2 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h2><p><strong>概念</strong></p><p>Maven是一个项目管理工具，它包含了一个项目对象模型（POM：Project Object Model），一组标准集合，一个项目生命瘦子（Project Lifecycle），一个依赖管理系统（Dependency Management System），和用来运行定义在生命周期阶段（phase）中插件（plugin）目标（goal）的逻辑。</p><p><strong>功能</strong></p><p>帮助程序员构建工程，管理jar报，编译代码，自动运行单元测试，打包，生成报表，以及部署项目，生成Web站点。</p><p>Maven本地仓库介绍：</p><ul><li><p>本地仓库：</p><p>用来存储从远程仓库或中央仓库下载的插件和jar包，项目使用一些插件或jar包，优先从本地仓库查找</p></li><li><p>远程仓库：</p><p>如果本地需要插件或jar包，本地仓库没有，默认是从远程仓库下载。远程仓库可以在互联网内，也可以子啊局域网内。</p></li><li><p>中央仓库：</p><p>在maven软件中内置一个远程仓库地址：<code>http://repo1.maven.org/maven2</code>，它是中央仓库，服务与整个互联网，它是由Maven团队自己维护，里面存储了非常全的jar包，它包含了世界上大部分流行的开源项目构件。但是由于在国外，下载速度慢，不利于使用，可改为使用国内公司架设的远程仓库。</p></li></ul><p><strong>Maven目录结构：</strong></p><ul><li>src 源码<ul><li>main：主工程代码<ul><li>java：主工程代码</li><li>resources：需要使用的配置文件</li><li>webapp：web项目的资源目录（jap/html/WEB-INF），有web项目时存在</li></ul></li><li>test：测试目录<ul><li>java：测试代码</li><li>resources：测试需要使用的配置文件</li></ul></li></ul></li><li>pom.xml：项目和核心配置文件</li></ul><p><strong>常用命令：</strong></p><ul><li>compile：编译，将 src/main/java 下的文件编译为 class 文件输出到 target 目录下</li><li>clean：清理，执行 clean会删除 target 目录及内容</li><li>package：打包，对于 java 工程执行package打成 jar 包，对于web工程打成war 包</li><li>install：安装，执行 install 将maven打成 jar 包或war 包发布到本地仓库</li><li>注意：当后面的命令执行时，前面的操作过程也都会自动执行</li></ul><p><strong>Maven的生命周期</strong></p><ul><li>Clean：在进行真正的构建之前进行一些清理工作</li><li>核心构建：编译、测试、打包、部署等等</li><li>站点发布</li></ul><p><strong>Maven坐标</strong><br>概念：被Maven管理的资源的唯一标识</p><ul><li>groupid：组织名称</li><li>artifactid：模块名称</li><li>version：版本号</li></ul><p>坐标搜索：<a href="https://mvnrepository.com/">Maven Repository</a></p><p><strong>依赖的范围</strong></p><p>项目依赖某个包，需要在pom.xml中添加包的坐标，而且要指定依赖范围<code>&lt;scope&gt;&lt;/scope&gt;</code></p><table><thead><tr><th align="center"><strong>依赖范围</strong></th><th align="center"><strong>对编译有效</strong></th><th align="center"><strong>对测试有效</strong></th><th align="center"><strong>对运行时有效</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="center">compile</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">spring-core</td></tr><tr><td align="center">test</td><td align="center">-</td><td align="center">✔️</td><td align="center">-</td><td align="center">Junit</td></tr><tr><td align="center">provided</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">-</td><td align="center">servlet-api</td></tr><tr><td align="center">runtime</td><td align="center">-</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">JDBC驱动</td></tr><tr><td align="center">system</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">-</td><td align="center">本地Maven仓库之外的类库</td></tr></tbody></table><p>依赖范围由强到弱的顺序是：compile &gt; provided &gt; runtime &gt; test</p><p>使用方式：</p><ul><li>默认引入 的 jar 包 ——- compile 【默认范围 可以不写】（编译、测试、运行都有效 ）</li><li>servlet-api 、jsp-api ——- provided （编译、测试有效， 运行时无效防止和 tomcat 下 jar 包冲突）</li><li>jdbc 驱动 jar 包 —- runtime （测试、运行 有效 ）</li><li>junit —– test （测试有效）</li></ul><h2 id="Maven进阶"><a href="#Maven进阶" class="headerlink" title="Maven进阶"></a>Maven进阶</h2><h3 id="1、分模块开发与设计"><a href="#1、分模块开发与设计" class="headerlink" title="1、分模块开发与设计"></a>1、分模块开发与设计</h3><p><strong>意义：</strong><br>使得各个模块中仅包含当前模块对应的功能与配置文件，满足不同模块之间的共享的需求</p><p><strong>步骤</strong><br>    1、使用install指令将当前模块发布到本地仓库</p><p>​    2、需要依赖当前模块的模块通过导入当前模块的坐标进行使用</p><h3 id="2、依赖管理"><a href="#2、依赖管理" class="headerlink" title="2、依赖管理"></a>2、依赖管理</h3><h4 id="1-依赖传递"><a href="#1-依赖传递" class="headerlink" title="1.依赖传递"></a>1.依赖传递</h4><p>依赖具有传递性，模块1依赖模块2，而模块2依赖模块3、4、5等模块，此时1抹开均可以使用这些依赖</p><ul><li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li><li>简介依赖：被依赖的资源如果依赖其他资源，则当前项目间接依赖其他资源</li></ul><p><strong>依赖传递冲突问题：</strong></p><ul><li>路径优先：当依赖中出现了相同的资源时，层级越深，优先级越低，层级越浅，优先级越高</li><li>声明优先：当资源在相同层级被依赖时，配置顺序考前的覆盖配置顺序靠后的</li><li>特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的，即后配置的优先级高</li></ul><h4 id="2-可选依赖"><a href="#2-可选依赖" class="headerlink" title="2.可选依赖"></a>2.可选依赖</h4><p>可选依赖是隐藏当前工程所依赖的资源，隐藏后对应的资源不具有依赖传递性，即对外隐藏当前依赖的资源（不透明）</p><p>在对应资源的坐标中添加，true表示隐藏，false表示不隐藏</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-排序依赖"><a href="#3-排序依赖" class="headerlink" title="3.排序依赖"></a>3.排序依赖</h4><p>排除依赖是指在当前引用的资源中将其中的某些依赖排除。在某些资源不可通过可选依赖进行隐藏时，可使用排除依赖，即主动断开依赖的资源，被排除的资源无需指定版本（不需要）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、聚合"><a href="#3、聚合" class="headerlink" title="3、聚合"></a>3、聚合</h3><ul><li>聚合：将多个模块组织成一个整体，同时对整个项目进行构建的过程称为聚合</li><li>聚合工程：通常是一个不具有业务功能的空工程（有且仅有一个pom文件）</li><li>作用：使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建<ul><li>当工程中的莫格模块更新时，必须保障工程中与已更新模块关联的模块同步更新，使用聚合工程可以解决批量模块同步构建的问题</li></ul></li></ul><p><strong>步骤</strong></p><p>​    1、创建聚合工程</p><p>​    2、指定聚合工程的打包方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    3、设置所管理的模块名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置各个模块的路径即可 如 ../maven-xxx --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4、继承"><a href="#4、继承" class="headerlink" title="4、继承"></a>4、继承</h3><p><strong>概念</strong><br>继承描述的是两个工程之间的关系，与Java中的继承类似，子工程可以继承父工程的配置信息，常见与依赖关系的继承</p><p><strong>作用</strong></p><ul><li>简化配置</li><li>减少版本冲突</li></ul><p><strong>配置</strong><br>在子工程中配置所继承的父工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span><span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span><span class="comment">&lt;!--(可选配置)通过相对路径可以快速找到父工程 如：../maven-parent/pom.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在父工程中配置可选的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在子工程中根据需要配置上述的可选依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>聚合与继承的区别</strong></p><ul><li>作用：<ul><li>聚合用于快速构建项目</li><li>继承用于快速配置</li></ul></li><li>相同点<ul><li>打包方式均为pom</li><li>均属于设计型模块，无实际模块内容</li></ul></li><li>不同点<ul><li>聚合在当前模块中配置关系，可以感知参与聚合的模块有哪些</li><li>继承在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul></li></ul><h3 id="5、属性"><a href="#5、属性" class="headerlink" title="5、属性"></a>5、属性</h3><p>通过配置属性对版本进行统一管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义变量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>配置文件加载pom中的属性</strong><br>    1、自定义属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql//.....<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    2、配置文件中引用属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=$&#123;jdbc.url&#125;</span><br></pre></td></tr></table></figure><p>​    3、开启资源文件目录加载属性的过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用内置属性$&#123;project.baseject&#125;进行统一配置--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--开启--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filter</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    4、配置maven打包war包时，可以使用以下配置忽略web.xml配置检查</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">failOnMissingWebXml</span>&gt;</span>false<span class="tag">&lt;/<span class="name">failOnMissingWebXml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>属性分类</strong><br>    1、自定义属性</p><p>​    2、内置属性：<code>$&#123;basedir&#125;</code>、<code>$&#123;vesrsion&#125;</code>等</p><p>​    3、Setting属性：<code>$&#123;settings.localRepository&#125;</code>等</p><p>​    4、Java系统属性：<code>$&#123;user.home&#125;</code>等</p><p>​    5、环境变量属性：<code>$&#123;env.JAVA_HOME&#125;</code>等</p><h3 id="6、版本管理"><a href="#6、版本管理" class="headerlink" title="6、版本管理"></a>6、版本管理</h3><ul><li>工程版本<ul><li>SNAPSHOT(快照版本)<ul><li>项目开发工程中临时输出的版本，称为快照版本</li><li>快照版本随着开发的进展不断更新</li></ul></li><li>RELEASE(发布版本)<ul><li>项目开发到阶段里程碑后，向外部发布较为稳定的版本。此时版本所对应的构件文件相对稳定，即</li><li>进行功能的后续开发，也不会改变当前发布版本内容，称为发布版本</li></ul></li></ul></li><li>发布版本<ul><li>alpha版</li><li>beta版</li><li>数字版</li></ul></li></ul><h3 id="7、多环境开发配置"><a href="#7、多环境开发配置" class="headerlink" title="7、多环境开发配置"></a>7、多环境开发配置</h3><p>实际开发环境中，存在多种不同的环境如测试环境、生成环境等等，而maven提供配置多种环境的设定，帮助开发者使用工程中快速切换环境</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置多环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dep<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql//.....1<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置为默认环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--生产环境--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql//.....2<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql//.....3<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>指定环境</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install(生命周期指令) -P id(环境id)</span><br></pre></td></tr></table></figure><h3 id="8、跳过测试"><a href="#8、跳过测试" class="headerlink" title="8、跳过测试"></a>8、跳过测试</h3><p>在存在开发功能更新中且未开发完毕或者需要快速打包等等情况下，常常需要跳过测试。</p><p><strong>使用</strong><br>    1、点击闪电按钮开启全局跳过</p><p>​    2、细粒度控制跳过测试，使用和指定包含和排除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--测试插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.xxxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--整体跳过--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">skipTest</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTest</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置排除部分不参与测试的内容</span></span><br><span class="line"><span class="comment">整体不跳过:</span></span><br><span class="line"><span class="comment">&lt;skipTest&gt;false&lt;/skipTest&gt;</span></span><br><span class="line"><span class="comment">排除内容:</span></span><br><span class="line"><span class="comment">&lt;excludes&gt;</span></span><br><span class="line"><span class="comment">&lt;exclude&gt;**/xxxTest.java&lt;/exclude&gt;</span></span><br><span class="line"><span class="comment">&lt;/excludes&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、使用指定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package(生命周期指令) -D skipTests</span><br></pre></td></tr></table></figure><h3 id="9、私服"><a href="#9、私服" class="headerlink" title="9、私服"></a>9、私服</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>私服是一台独立的服务器，用于解决团队内部的资源共享和资源同步问题。</p><p>Nexus，一款maven私服产品，下载：<a href="https://help.sonatype.com/repomanager3/product-information/download">https://help.sonatype.com/repomanager3/product-information/download</a></p><p><strong>安装与启动</strong></p><ul><li>启动服务器（命令行启动）：nexus.exe /run nexus</li><li>访问服务器（默认端口：8081）：<a href="http://localhost:8081/">http://localhost:8081</a></li><li>修改基础配置信息<ul><li>etc/nexus-default.properties 文件中保存nexus的基础配置信息，包括默认端口</li></ul></li><li>修改服务器运行配置信息<ul><li>bin/nexus.vmoptions 文件中保存nexus服务器启动对应的配置信息，如默认占用内存空间</li></ul></li></ul><h4 id="2-仓库分类"><a href="#2-仓库分类" class="headerlink" title="2.仓库分类"></a>2.仓库分类</h4><table><thead><tr><th align="center"><strong>仓库类别</strong></th><th align="center"><strong>英文</strong></th><th align="center"><strong>功能</strong></th><th align="center"><strong>关联操作</strong></th></tr></thead><tbody><tr><td align="center">宿主仓库</td><td align="center">hosted</td><td align="center">保存自主研发+第三方资源</td><td align="center">上传</td></tr><tr><td align="center">代理仓库</td><td align="center">proxy</td><td align="center">代理连接中央仓库</td><td align="center">下载</td></tr><tr><td align="center">仓库组</td><td align="center">group</td><td align="center">为仓库编组简化下载操作</td><td align="center">下载</td></tr></tbody></table><ul><li>宿主仓库：保存无法从中央仓库获取的资源<ul><li>自主研发资源</li><li>第三方非开源资源</li></ul></li><li>代理仓库：代理远程仓库，通过nexus访问其他公共仓库</li><li>仓库组：将若干仓库设计成一个组，简化配置<ul><li>不用于保存资料，属于设计型仓库</li></ul></li></ul><h4 id="3-资源上传与下载"><a href="#3-资源上传与下载" class="headerlink" title="3.资源上传与下载"></a>3.资源上传与下载</h4><p><strong>配置</strong></p><ul><li>配置本地仓库访问私服权限</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--私服的访问权限--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>zyl-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>zyl-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置本地仓库访问私服的路径</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--私服的访问路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在pom.xml配置当前项目访问私服上次资源的保存位置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>zyl-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/zyl-release/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>      </span><br><span class="line"> <span class="tag">&lt;/<span class="name">repository</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>zyl-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/zyl-snapshot/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>资源上传 ：deploy指定</li></ul><p>（注：本文参考<a href="https://blog.csdn.net/L1ghtn1nggggg/article/details/124437648%EF%BC%89">https://blog.csdn.net/L1ghtn1nggggg/article/details/124437648）</a></p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/2022/12/10/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/10/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><h2 id="Git——世界上最先进的分布式版本控制系统"><a href="#Git——世界上最先进的分布式版本控制系统" class="headerlink" title="Git——世界上最先进的分布式版本控制系统"></a>Git——世界上最先进的分布式版本控制系统</h2><p>​        <strong>学习git，可以去Git菜鸟</strong> <a href="https://www.runoob.com/git/git-tutorial.html">Git菜鸟教程</a></p><h2 id="一、Git简介"><a href="#一、Git简介" class="headerlink" title="一、Git简介"></a>一、Git简介</h2><h3 id="1、Git的诞生"><a href="#1、Git的诞生" class="headerlink" title="1、Git的诞生"></a>1、Git的诞生</h3><p>Git是Linus花了两周时间自己用<strong>C语言</strong>写了一个分布式版本控制系统</p><h3 id="2、分布式VS集中式"><a href="#2、分布式VS集中式" class="headerlink" title="2、分布式VS集中式"></a>2、分布式VS集中式</h3><ul><li>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆<ul><li>最大缺点：必须联网才能工作</li><li>其次，安全性较低，当中央服务器出了问题，所有人都没法工作</li></ul></li><li>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库。当你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了<ul><li>优点：避免了集中式的缺点</li></ul></li></ul><h2 id="二、在windows上安装Git"><a href="#二、在windows上安装Git" class="headerlink" title="二、在windows上安装Git"></a>二、在windows上安装Git</h2><p>从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，然后按默认选项安装即可</p><p>安装完成后，在开始菜单里找到“Git”  —&gt;“Git Bash”，会跳出一个命令行窗口，说明Git安装成功</p><p>安装成功后，还需要最后一步设置，在命令行输入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><blockquote><p>因为Git是分布式版本控制系统，所以每个机器都必须自报家门：你的名字和你的Email地址</p></blockquote><h2 id="三、版本库的创建"><a href="#三、版本库的创建" class="headerlink" title="三、版本库的创建"></a>三、版本库的创建</h2><p>版本库又称仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都可以跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原</p><p>假如你想管理某个目录里面的所有文件</p><p>你需要通过命令行cmd进入该目录下，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><blockquote><p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文</p></blockquote><ul><li><p>你会发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了</p></li><li><p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见</p></li></ul><h2 id="四、工作去和暂存区"><a href="#四、工作去和暂存区" class="headerlink" title="四、工作去和暂存区"></a>四、工作去和暂存区</h2><p>工作区（Working Directory）：就是你在电脑里能看到的目录。</p><p>版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是git的版本库。Git的版本库里村里很多东西，其中最重要的就是称为stage（或者交iudex）的暂存区。还有Git为什么自动创建的第一个分支master，以及指向master的一个指针叫HEAD</p><p><img src="/img/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Git工作流程"></p><h2 id="五、远程仓库"><a href="#五、远程仓库" class="headerlink" title="五、远程仓库"></a>五、远程仓库</h2><h3 id="1、从远程仓库克隆到本地库"><a href="#1、从远程仓库克隆到本地库" class="headerlink" title="1、从远程仓库克隆到本地库"></a>1、从远程仓库克隆到本地库</h3><p><a href="https://github.com/">GitHub</a>这个网站就是提供Git仓库托管服务的，只要注册一个GitHub账号，就可以免费获得Git远程仓库</p><p>远程库创建好后，可以用命令<code>git clone</code>克隆一个本地库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:perfect-code-hzy/supermall.git</span><br></pre></td></tr></table></figure><blockquote><p>注意把Git库的地址换成你自己的，然后进入你想要创建到的目录看看，已经有对应的文件了</p></blockquote><h3 id="2、项目从本地库推送到github远程库管理"><a href="#2、项目从本地库推送到github远程库管理" class="headerlink" title="2、项目从本地库推送到github远程库管理"></a>2、项目从本地库推送到github远程库管理</h3><ol><li>github上创建git仓库为supermall</li><li>创建项目：vue create supermall</li><li><code>git init</code>初始化仓库</li><li><code>git status</code>//查看当前库的状态</li><li><code>git diff</code> //查看修改内容</li><li><code>git add .</code> //把所有文件提交到暂存区，即本地库</li><li><code>git commit -m &#39;初始化项目&#39;</code> //即此次提交的说明</li></ol><p>以上是提交到本地仓库，以下是提交到github远程库</p><ol start="9"><li><p><code>git remote add origin https://github.com/JiangH156/JiangH156.github.io.git</code>//将本地仓库关联到远程仓库</p></li><li><p><code>git remote -v</code> // 列出已关联的库，带有url</p></li><li><p><code>git remote show JiangH156.github.io</code> //查看某一指定库</p></li><li><p><code>git pull --rebase origin master</code> //当出现错误原因是github中的README.md文件不在本地代码目录中,通过该命令进行代码合并</p></li><li><p><code>git push -u origin master</code> // 提交到远程库</p></li><li><p>撤销修改</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code><br>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt; file &gt;</code>，就回到了场景1，第二步按场景1操作<br>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，<strong>不过前提是没有推送到远程库</strong></p></li><li><p>删除文件</p></li></ol><p>​        <code>git rm file</code> 用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p><h2 id="六、分支管理"><a href="#六、分支管理" class="headerlink" title="六、分支管理"></a>六、分支管理</h2><p>你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作</p><h4 id="1、创建和合并分支（重点）"><a href="#1、创建和合并分支（重点）" class="headerlink" title="1、创建和合并分支（重点）"></a>1、创建和合并分支（重点）</h4><p>使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p><ul><li>创建dev分支并切换到dev分支</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">// 或者</span><br><span class="line">git switch -c <span class="tag">&lt;<span class="name">dev</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建并切换相当于两条命令（略）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev 或者 git switch &lt;dev&gt;</span><br></pre></td></tr></table></figure><ul><li>查看分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">* dev </span><br><span class="line">  master</span><br></pre></td></tr></table></figure><blockquote><p>当前分支前面会标一个*号</p></blockquote><ul><li>当dev分支的工作完成，我们就可以合并分支到主分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master    //切换会master分支</span><br><span class="line">git merge dev    //把dev分支的工作成果合并到master分支上</span><br><span class="line">git push    //推送到远程仓库</span><br></pre></td></tr></table></figure><ul><li>远程仓库保存login分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout login//切换login分支</span><br><span class="line">git push -u origin login //推送到云端origin仓库的login分支</span><br></pre></td></tr></table></figure><ul><li>合并完成后，删除dev分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><h4 id="2、合并分支冲突（略）"><a href="#2、合并分支冲突（略）" class="headerlink" title="2、合并分支冲突（略）"></a>2、合并分支冲突（略）</h4><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图</p><h4 id="3、分支策略（略）"><a href="#3、分支策略（略）" class="headerlink" title="3、分支策略（略）"></a>3、分支策略（略）</h4><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><ul><li>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活</li><li>干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本</li><li>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><ul><li>合并后，我们用<code>git log</code>看看分支历史</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="4、bug分支"><a href="#4、bug分支" class="headerlink" title="4、bug分支"></a>4、bug分支</h4><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交，但由于工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure><p>然后，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地<strong>创建分支来修复bug</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">切换到master分支</span><br><span class="line">$ git checkout master</span><br><span class="line">创建并切换修复bug的分支</span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">然后修复bug</span><br><span class="line">$ vi readme.txt</span><br><span class="line">提交文件</span><br><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &#x27;fix bug 101&#x27;</span><br><span class="line">切换到master分支</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">删除修复bug的分支</span><br><span class="line">$ git branch -d issue-101</span><br><span class="line">$ git checkout dev</span><br><span class="line">查看刚才存放的工作现场</span><br><span class="line">$ git stash list</span><br><span class="line">恢复工作现场</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><p>工作现场恢复的两个方法：</p><ul><li>用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</li><li>用<code>git stash pop</code>，恢复的同时把stash内容也删了</li></ul><p>同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。</p><blockquote><p>注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来</p></blockquote><p>为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2</span><br></pre></td></tr></table></figure><h4 id="5、Feature分支"><a href="#5、Feature分支" class="headerlink" title="5、Feature分支"></a>5、Feature分支</h4><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>一般删除用<code>-d</code>，有时会删除不掉。如要丢弃一个没有被合并过的分支，需要使用大写的<code>-D</code>参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature-1</span><br></pre></td></tr></table></figure><h4 id="6、多人协作"><a href="#6、多人协作" class="headerlink" title="6、多人协作"></a>6、多人协作</h4><ol><li>分支推送<ul><li>master分支是主分支，因此要时刻与远程同步；</li><li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul></li><li>工作模式<ul><li>首先，可以试图用<code>git push origin &lt; branch-name &gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt; branch-name &gt;</code>推送就能成功！</li><li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt; branch-name &gt; origin/&lt; branch-name &gt;</code>。</li></ul></li></ol><h4 id="7、Rebase"><a href="#7、Rebase" class="headerlink" title="7、Rebase"></a>7、Rebase</h4><p>多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。这样会造成查看提交历史会出现很多分支。</p><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比</li></ul><h2 id="七、标签管理"><a href="#七、标签管理" class="headerlink" title="七、标签管理"></a>七、标签管理</h2><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的</p><h4 id="1、创建标签"><a href="#1、创建标签" class="headerlink" title="1、创建标签"></a>1、创建标签</h4><ul><li>首先，切换到需要打标签的分支上，打标签即可</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">$ git tag v1.0</span><br><span class="line">查看所有标签</span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><ul><li>可以查看历史提交的commit id，为其打上标签</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br></pre></td></tr></table></figure><ul><li>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是f52c633，敲入命令：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br><span class="line">查看标签信息：</span><br><span class="line">$ git show <span class="tag">&lt;<span class="name">tagname</span>&gt;</span></span><br><span class="line">还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字</span><br><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure><blockquote><p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p></blockquote><h4 id="2、操作标签"><a href="#2、操作标签" class="headerlink" title="2、操作标签"></a>2、操作标签</h4><p>创建的标签都只存储在本地，不会自动推送到远程。打错的标签可以在本地安全删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">删除标签</span><br><span class="line">$ git tag -d v0.1</span><br><span class="line">推送某个标签到远程</span><br><span class="line">$ git push origin <span class="tag">&lt;<span class="name">tagname</span>&gt;</span></span><br><span class="line">一次性推送全部尚未推送到远程的本地标签</span><br><span class="line">$ git push origin --tags</span><br><span class="line">如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</span><br><span class="line">$ git tag -d v0.9</span><br><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">要看看是否真的从远程库删除了标签，可以登陆GitHub查看</span><br></pre></td></tr></table></figure><h2 id="九、Github和Gitee使用（重点）"><a href="#九、Github和Gitee使用（重点）" class="headerlink" title="九、Github和Gitee使用（重点）"></a>九、Github和Gitee使用（重点）</h2><h4 id="1、Github上搜索项目技巧"><a href="#1、Github上搜索项目技巧" class="headerlink" title="1、Github上搜索项目技巧"></a>1、Github上搜索项目技巧</h4><p><img src="/img/Github%E6%90%9C%E7%B4%A2%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7.png" alt="Github搜索项目技巧"></p><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h3 id="链接-—-gt-https-blog-csdn-net-halaoda-article-details-78661334"><a href="#链接-—-gt-https-blog-csdn-net-halaoda-article-details-78661334" class="headerlink" title="链接 —&gt; https://blog.csdn.net/halaoda/article/details/78661334"></a>链接 —&gt; <a href="https://blog.csdn.net/halaoda/article/details/78661334">https://blog.csdn.net/halaoda/article/details/78661334</a></h3><p>(注：该篇参考自<a href="https://blog.csdn.net/Best_arrangement/article/details/107745523">https://blog.csdn.net/Best_arrangement/article/details/107745523</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
